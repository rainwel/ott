// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: searchinfo_response.proto

#ifndef PROTOBUF_searchinfo_5fresponse_2eproto__INCLUDED
#define PROTOBUF_searchinfo_5fresponse_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace cloudbox {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_searchinfo_5fresponse_2eproto();
void protobuf_AssignDesc_searchinfo_5fresponse_2eproto();
void protobuf_ShutdownFile_searchinfo_5fresponse_2eproto();

class FilterInfo;
class SearchInfo;

// ===================================================================

class FilterInfo : public ::google::protobuf::MessageLite {
 public:
  FilterInfo();
  virtual ~FilterInfo();

  FilterInfo(const FilterInfo& from);

  inline FilterInfo& operator=(const FilterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FilterInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FilterInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FilterInfo* other);

  // implements Message ----------------------------------------------

  FilterInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FilterInfo& from);
  void MergeFrom(const FilterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.BoxInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::cloudbox::protobuf::BoxInfo& result(int index) const;
  inline ::cloudbox::protobuf::BoxInfo* mutable_result(int index);
  inline ::cloudbox::protobuf::BoxInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.FilterInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo > result_;
  ::google::protobuf::int32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_searchinfo_5fresponse_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_searchinfo_5fresponse_2eproto();
  #endif
  friend void protobuf_AssignDesc_searchinfo_5fresponse_2eproto();
  friend void protobuf_ShutdownFile_searchinfo_5fresponse_2eproto();

  void InitAsDefaultInstance();
  static FilterInfo* default_instance_;
};
// -------------------------------------------------------------------

class SearchInfo : public ::google::protobuf::MessageLite {
 public:
  SearchInfo();
  virtual ~SearchInfo();

  SearchInfo(const SearchInfo& from);

  inline SearchInfo& operator=(const SearchInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SearchInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SearchInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SearchInfo* other);

  // implements Message ----------------------------------------------

  SearchInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SearchInfo& from);
  void MergeFrom(const SearchInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional int32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.BoxInfo result = 3;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline const ::cloudbox::protobuf::BoxInfo& result(int index) const;
  inline ::cloudbox::protobuf::BoxInfo* mutable_result(int index);
  inline ::cloudbox::protobuf::BoxInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
      mutable_result();

  // optional string subtitle = 4;
  inline bool has_subtitle() const;
  inline void clear_subtitle();
  static const int kSubtitleFieldNumber = 4;
  inline const ::std::string& subtitle() const;
  inline void set_subtitle(const ::std::string& value);
  inline void set_subtitle(const char* value);
  inline void set_subtitle(const char* value, size_t size);
  inline ::std::string* mutable_subtitle();
  inline ::std::string* release_subtitle();
  inline void set_allocated_subtitle(::std::string* subtitle);

  // optional float offsetY = 5;
  inline bool has_offsety() const;
  inline void clear_offsety();
  static const int kOffsetYFieldNumber = 5;
  inline float offsety() const;
  inline void set_offsety(float value);

  // optional .cloudbox.protobuf.ImageInfo background = 6;
  inline bool has_background() const;
  inline void clear_background();
  static const int kBackgroundFieldNumber = 6;
  inline const ::cloudbox::protobuf::ImageInfo& background() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_background();
  inline ::cloudbox::protobuf::ImageInfo* release_background();
  inline void set_allocated_background(::cloudbox::protobuf::ImageInfo* background);

  // optional .cloudbox.protobuf.FilterInfo filters = 7;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 7;
  inline const ::cloudbox::protobuf::FilterInfo& filters() const;
  inline ::cloudbox::protobuf::FilterInfo* mutable_filters();
  inline ::cloudbox::protobuf::FilterInfo* release_filters();
  inline void set_allocated_filters(::cloudbox::protobuf::FilterInfo* filters);

  // repeated .cloudbox.protobuf.BoxInfo footerButtons = 8;
  inline int footerbuttons_size() const;
  inline void clear_footerbuttons();
  static const int kFooterButtonsFieldNumber = 8;
  inline const ::cloudbox::protobuf::BoxInfo& footerbuttons(int index) const;
  inline ::cloudbox::protobuf::BoxInfo* mutable_footerbuttons(int index);
  inline ::cloudbox::protobuf::BoxInfo* add_footerbuttons();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
      footerbuttons() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
      mutable_footerbuttons();

  // optional string id = 9;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 9;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .cloudbox.protobuf.BoxInfo bookmarkButtons = 10;
  inline int bookmarkbuttons_size() const;
  inline void clear_bookmarkbuttons();
  static const int kBookmarkButtonsFieldNumber = 10;
  inline const ::cloudbox::protobuf::BoxInfo& bookmarkbuttons(int index) const;
  inline ::cloudbox::protobuf::BoxInfo* mutable_bookmarkbuttons(int index);
  inline ::cloudbox::protobuf::BoxInfo* add_bookmarkbuttons();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
      bookmarkbuttons() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
      mutable_bookmarkbuttons();

  // optional string pname = 11;
  inline bool has_pname() const;
  inline void clear_pname();
  static const int kPnameFieldNumber = 11;
  inline const ::std::string& pname() const;
  inline void set_pname(const ::std::string& value);
  inline void set_pname(const char* value);
  inline void set_pname(const char* value, size_t size);
  inline ::std::string* mutable_pname();
  inline ::std::string* release_pname();
  inline void set_allocated_pname(::std::string* pname);

  // optional string ptitle = 12;
  inline bool has_ptitle() const;
  inline void clear_ptitle();
  static const int kPtitleFieldNumber = 12;
  inline const ::std::string& ptitle() const;
  inline void set_ptitle(const ::std::string& value);
  inline void set_ptitle(const char* value);
  inline void set_ptitle(const char* value, size_t size);
  inline ::std::string* mutable_ptitle();
  inline ::std::string* release_ptitle();
  inline void set_allocated_ptitle(::std::string* ptitle);

  // optional string pdesc = 13;
  inline bool has_pdesc() const;
  inline void clear_pdesc();
  static const int kPdescFieldNumber = 13;
  inline const ::std::string& pdesc() const;
  inline void set_pdesc(const ::std::string& value);
  inline void set_pdesc(const char* value);
  inline void set_pdesc(const char* value, size_t size);
  inline ::std::string* mutable_pdesc();
  inline ::std::string* release_pdesc();
  inline void set_allocated_pdesc(::std::string* pdesc);

  // optional int32 pgender = 14;
  inline bool has_pgender() const;
  inline void clear_pgender();
  static const int kPgenderFieldNumber = 14;
  inline ::google::protobuf::int32 pgender() const;
  inline void set_pgender(::google::protobuf::int32 value);

  // optional string spacing = 15;
  inline bool has_spacing() const;
  inline void clear_spacing();
  static const int kSpacingFieldNumber = 15;
  inline const ::std::string& spacing() const;
  inline void set_spacing(const ::std::string& value);
  inline void set_spacing(const char* value);
  inline void set_spacing(const char* value, size_t size);
  inline ::std::string* mutable_spacing();
  inline ::std::string* release_spacing();
  inline void set_allocated_spacing(::std::string* spacing);

  // optional .cloudbox.protobuf.ImageInfo backgroundClip = 16;
  inline bool has_backgroundclip() const;
  inline void clear_backgroundclip();
  static const int kBackgroundClipFieldNumber = 16;
  inline const ::cloudbox::protobuf::ImageInfo& backgroundclip() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_backgroundclip();
  inline ::cloudbox::protobuf::ImageInfo* release_backgroundclip();
  inline void set_allocated_backgroundclip(::cloudbox::protobuf::ImageInfo* backgroundclip);

  // optional int32 backgroundClipX = 17;
  inline bool has_backgroundclipx() const;
  inline void clear_backgroundclipx();
  static const int kBackgroundClipXFieldNumber = 17;
  inline ::google::protobuf::int32 backgroundclipx() const;
  inline void set_backgroundclipx(::google::protobuf::int32 value);

  // optional int32 backgroundClipY = 18;
  inline bool has_backgroundclipy() const;
  inline void clear_backgroundclipy();
  static const int kBackgroundClipYFieldNumber = 18;
  inline ::google::protobuf::int32 backgroundclipy() const;
  inline void set_backgroundclipy(::google::protobuf::int32 value);

  // optional int32 boxWidth = 19;
  inline bool has_boxwidth() const;
  inline void clear_boxwidth();
  static const int kBoxWidthFieldNumber = 19;
  inline ::google::protobuf::int32 boxwidth() const;
  inline void set_boxwidth(::google::protobuf::int32 value);

  // optional int32 boxHeight = 20;
  inline bool has_boxheight() const;
  inline void clear_boxheight();
  static const int kBoxHeightFieldNumber = 20;
  inline ::google::protobuf::int32 boxheight() const;
  inline void set_boxheight(::google::protobuf::int32 value);

  // optional float offsetX = 21;
  inline bool has_offsetx() const;
  inline void clear_offsetx();
  static const int kOffsetXFieldNumber = 21;
  inline float offsetx() const;
  inline void set_offsetx(float value);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.SearchInfo)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_subtitle();
  inline void clear_has_subtitle();
  inline void set_has_offsety();
  inline void clear_has_offsety();
  inline void set_has_background();
  inline void clear_has_background();
  inline void set_has_filters();
  inline void clear_has_filters();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pname();
  inline void clear_has_pname();
  inline void set_has_ptitle();
  inline void clear_has_ptitle();
  inline void set_has_pdesc();
  inline void clear_has_pdesc();
  inline void set_has_pgender();
  inline void clear_has_pgender();
  inline void set_has_spacing();
  inline void clear_has_spacing();
  inline void set_has_backgroundclip();
  inline void clear_has_backgroundclip();
  inline void set_has_backgroundclipx();
  inline void clear_has_backgroundclipx();
  inline void set_has_backgroundclipy();
  inline void clear_has_backgroundclipy();
  inline void set_has_boxwidth();
  inline void clear_has_boxwidth();
  inline void set_has_boxheight();
  inline void clear_has_boxheight();
  inline void set_has_offsetx();
  inline void clear_has_offsetx();

  ::std::string* title_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo > result_;
  ::google::protobuf::int32 total_;
  float offsety_;
  ::std::string* subtitle_;
  ::cloudbox::protobuf::ImageInfo* background_;
  ::cloudbox::protobuf::FilterInfo* filters_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo > footerbuttons_;
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo > bookmarkbuttons_;
  ::std::string* pname_;
  ::std::string* ptitle_;
  ::std::string* pdesc_;
  ::std::string* spacing_;
  ::google::protobuf::int32 pgender_;
  ::google::protobuf::int32 backgroundclipx_;
  ::cloudbox::protobuf::ImageInfo* backgroundclip_;
  ::google::protobuf::int32 backgroundclipy_;
  ::google::protobuf::int32 boxwidth_;
  ::google::protobuf::int32 boxheight_;
  float offsetx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_searchinfo_5fresponse_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_searchinfo_5fresponse_2eproto();
  #endif
  friend void protobuf_AssignDesc_searchinfo_5fresponse_2eproto();
  friend void protobuf_ShutdownFile_searchinfo_5fresponse_2eproto();

  void InitAsDefaultInstance();
  static SearchInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// FilterInfo

// optional int32 total = 1;
inline bool FilterInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterInfo::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 FilterInfo::total() const {
  return total_;
}
inline void FilterInfo::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated .cloudbox.protobuf.BoxInfo result = 2;
inline int FilterInfo::result_size() const {
  return result_.size();
}
inline void FilterInfo::clear_result() {
  result_.Clear();
}
inline const ::cloudbox::protobuf::BoxInfo& FilterInfo::result(int index) const {
  return result_.Get(index);
}
inline ::cloudbox::protobuf::BoxInfo* FilterInfo::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::cloudbox::protobuf::BoxInfo* FilterInfo::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
FilterInfo::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
FilterInfo::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// SearchInfo

// optional string title = 1;
inline bool SearchInfo::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchInfo::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& SearchInfo::title() const {
  return *title_;
}
inline void SearchInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SearchInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SearchInfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* SearchInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchInfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 total = 2;
inline bool SearchInfo::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchInfo::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchInfo::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 SearchInfo::total() const {
  return total_;
}
inline void SearchInfo::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated .cloudbox.protobuf.BoxInfo result = 3;
inline int SearchInfo::result_size() const {
  return result_.size();
}
inline void SearchInfo::clear_result() {
  result_.Clear();
}
inline const ::cloudbox::protobuf::BoxInfo& SearchInfo::result(int index) const {
  return result_.Get(index);
}
inline ::cloudbox::protobuf::BoxInfo* SearchInfo::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::cloudbox::protobuf::BoxInfo* SearchInfo::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
SearchInfo::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
SearchInfo::mutable_result() {
  return &result_;
}

// optional string subtitle = 4;
inline bool SearchInfo::has_subtitle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchInfo::set_has_subtitle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchInfo::clear_has_subtitle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchInfo::clear_subtitle() {
  if (subtitle_ != &::google::protobuf::internal::kEmptyString) {
    subtitle_->clear();
  }
  clear_has_subtitle();
}
inline const ::std::string& SearchInfo::subtitle() const {
  return *subtitle_;
}
inline void SearchInfo::set_subtitle(const ::std::string& value) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(value);
}
inline void SearchInfo::set_subtitle(const char* value) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(value);
}
inline void SearchInfo::set_subtitle(const char* value, size_t size) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchInfo::mutable_subtitle() {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  return subtitle_;
}
inline ::std::string* SearchInfo::release_subtitle() {
  clear_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtitle_;
    subtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchInfo::set_allocated_subtitle(::std::string* subtitle) {
  if (subtitle_ != &::google::protobuf::internal::kEmptyString) {
    delete subtitle_;
  }
  if (subtitle) {
    set_has_subtitle();
    subtitle_ = subtitle;
  } else {
    clear_has_subtitle();
    subtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float offsetY = 5;
inline bool SearchInfo::has_offsety() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchInfo::set_has_offsety() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchInfo::clear_has_offsety() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchInfo::clear_offsety() {
  offsety_ = 0;
  clear_has_offsety();
}
inline float SearchInfo::offsety() const {
  return offsety_;
}
inline void SearchInfo::set_offsety(float value) {
  set_has_offsety();
  offsety_ = value;
}

// optional .cloudbox.protobuf.ImageInfo background = 6;
inline bool SearchInfo::has_background() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SearchInfo::set_has_background() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SearchInfo::clear_has_background() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SearchInfo::clear_background() {
  if (background_ != NULL) background_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_background();
}
inline const ::cloudbox::protobuf::ImageInfo& SearchInfo::background() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return background_ != NULL ? *background_ : *default_instance().background_;
#else
  return background_ != NULL ? *background_ : *default_instance_->background_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* SearchInfo::mutable_background() {
  set_has_background();
  if (background_ == NULL) background_ = new ::cloudbox::protobuf::ImageInfo;
  return background_;
}
inline ::cloudbox::protobuf::ImageInfo* SearchInfo::release_background() {
  clear_has_background();
  ::cloudbox::protobuf::ImageInfo* temp = background_;
  background_ = NULL;
  return temp;
}
inline void SearchInfo::set_allocated_background(::cloudbox::protobuf::ImageInfo* background) {
  delete background_;
  background_ = background;
  if (background) {
    set_has_background();
  } else {
    clear_has_background();
  }
}

// optional .cloudbox.protobuf.FilterInfo filters = 7;
inline bool SearchInfo::has_filters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SearchInfo::set_has_filters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SearchInfo::clear_has_filters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SearchInfo::clear_filters() {
  if (filters_ != NULL) filters_->::cloudbox::protobuf::FilterInfo::Clear();
  clear_has_filters();
}
inline const ::cloudbox::protobuf::FilterInfo& SearchInfo::filters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filters_ != NULL ? *filters_ : *default_instance().filters_;
#else
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
#endif
}
inline ::cloudbox::protobuf::FilterInfo* SearchInfo::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::cloudbox::protobuf::FilterInfo;
  return filters_;
}
inline ::cloudbox::protobuf::FilterInfo* SearchInfo::release_filters() {
  clear_has_filters();
  ::cloudbox::protobuf::FilterInfo* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void SearchInfo::set_allocated_filters(::cloudbox::protobuf::FilterInfo* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
}

// repeated .cloudbox.protobuf.BoxInfo footerButtons = 8;
inline int SearchInfo::footerbuttons_size() const {
  return footerbuttons_.size();
}
inline void SearchInfo::clear_footerbuttons() {
  footerbuttons_.Clear();
}
inline const ::cloudbox::protobuf::BoxInfo& SearchInfo::footerbuttons(int index) const {
  return footerbuttons_.Get(index);
}
inline ::cloudbox::protobuf::BoxInfo* SearchInfo::mutable_footerbuttons(int index) {
  return footerbuttons_.Mutable(index);
}
inline ::cloudbox::protobuf::BoxInfo* SearchInfo::add_footerbuttons() {
  return footerbuttons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
SearchInfo::footerbuttons() const {
  return footerbuttons_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
SearchInfo::mutable_footerbuttons() {
  return &footerbuttons_;
}

// optional string id = 9;
inline bool SearchInfo::has_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SearchInfo::set_has_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SearchInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SearchInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SearchInfo::id() const {
  return *id_;
}
inline void SearchInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SearchInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SearchInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SearchInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .cloudbox.protobuf.BoxInfo bookmarkButtons = 10;
inline int SearchInfo::bookmarkbuttons_size() const {
  return bookmarkbuttons_.size();
}
inline void SearchInfo::clear_bookmarkbuttons() {
  bookmarkbuttons_.Clear();
}
inline const ::cloudbox::protobuf::BoxInfo& SearchInfo::bookmarkbuttons(int index) const {
  return bookmarkbuttons_.Get(index);
}
inline ::cloudbox::protobuf::BoxInfo* SearchInfo::mutable_bookmarkbuttons(int index) {
  return bookmarkbuttons_.Mutable(index);
}
inline ::cloudbox::protobuf::BoxInfo* SearchInfo::add_bookmarkbuttons() {
  return bookmarkbuttons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >&
SearchInfo::bookmarkbuttons() const {
  return bookmarkbuttons_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::BoxInfo >*
SearchInfo::mutable_bookmarkbuttons() {
  return &bookmarkbuttons_;
}

// optional string pname = 11;
inline bool SearchInfo::has_pname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SearchInfo::set_has_pname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SearchInfo::clear_has_pname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SearchInfo::clear_pname() {
  if (pname_ != &::google::protobuf::internal::kEmptyString) {
    pname_->clear();
  }
  clear_has_pname();
}
inline const ::std::string& SearchInfo::pname() const {
  return *pname_;
}
inline void SearchInfo::set_pname(const ::std::string& value) {
  set_has_pname();
  if (pname_ == &::google::protobuf::internal::kEmptyString) {
    pname_ = new ::std::string;
  }
  pname_->assign(value);
}
inline void SearchInfo::set_pname(const char* value) {
  set_has_pname();
  if (pname_ == &::google::protobuf::internal::kEmptyString) {
    pname_ = new ::std::string;
  }
  pname_->assign(value);
}
inline void SearchInfo::set_pname(const char* value, size_t size) {
  set_has_pname();
  if (pname_ == &::google::protobuf::internal::kEmptyString) {
    pname_ = new ::std::string;
  }
  pname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchInfo::mutable_pname() {
  set_has_pname();
  if (pname_ == &::google::protobuf::internal::kEmptyString) {
    pname_ = new ::std::string;
  }
  return pname_;
}
inline ::std::string* SearchInfo::release_pname() {
  clear_has_pname();
  if (pname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pname_;
    pname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchInfo::set_allocated_pname(::std::string* pname) {
  if (pname_ != &::google::protobuf::internal::kEmptyString) {
    delete pname_;
  }
  if (pname) {
    set_has_pname();
    pname_ = pname;
  } else {
    clear_has_pname();
    pname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ptitle = 12;
inline bool SearchInfo::has_ptitle() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SearchInfo::set_has_ptitle() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SearchInfo::clear_has_ptitle() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SearchInfo::clear_ptitle() {
  if (ptitle_ != &::google::protobuf::internal::kEmptyString) {
    ptitle_->clear();
  }
  clear_has_ptitle();
}
inline const ::std::string& SearchInfo::ptitle() const {
  return *ptitle_;
}
inline void SearchInfo::set_ptitle(const ::std::string& value) {
  set_has_ptitle();
  if (ptitle_ == &::google::protobuf::internal::kEmptyString) {
    ptitle_ = new ::std::string;
  }
  ptitle_->assign(value);
}
inline void SearchInfo::set_ptitle(const char* value) {
  set_has_ptitle();
  if (ptitle_ == &::google::protobuf::internal::kEmptyString) {
    ptitle_ = new ::std::string;
  }
  ptitle_->assign(value);
}
inline void SearchInfo::set_ptitle(const char* value, size_t size) {
  set_has_ptitle();
  if (ptitle_ == &::google::protobuf::internal::kEmptyString) {
    ptitle_ = new ::std::string;
  }
  ptitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchInfo::mutable_ptitle() {
  set_has_ptitle();
  if (ptitle_ == &::google::protobuf::internal::kEmptyString) {
    ptitle_ = new ::std::string;
  }
  return ptitle_;
}
inline ::std::string* SearchInfo::release_ptitle() {
  clear_has_ptitle();
  if (ptitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ptitle_;
    ptitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchInfo::set_allocated_ptitle(::std::string* ptitle) {
  if (ptitle_ != &::google::protobuf::internal::kEmptyString) {
    delete ptitle_;
  }
  if (ptitle) {
    set_has_ptitle();
    ptitle_ = ptitle;
  } else {
    clear_has_ptitle();
    ptitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pdesc = 13;
inline bool SearchInfo::has_pdesc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SearchInfo::set_has_pdesc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SearchInfo::clear_has_pdesc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SearchInfo::clear_pdesc() {
  if (pdesc_ != &::google::protobuf::internal::kEmptyString) {
    pdesc_->clear();
  }
  clear_has_pdesc();
}
inline const ::std::string& SearchInfo::pdesc() const {
  return *pdesc_;
}
inline void SearchInfo::set_pdesc(const ::std::string& value) {
  set_has_pdesc();
  if (pdesc_ == &::google::protobuf::internal::kEmptyString) {
    pdesc_ = new ::std::string;
  }
  pdesc_->assign(value);
}
inline void SearchInfo::set_pdesc(const char* value) {
  set_has_pdesc();
  if (pdesc_ == &::google::protobuf::internal::kEmptyString) {
    pdesc_ = new ::std::string;
  }
  pdesc_->assign(value);
}
inline void SearchInfo::set_pdesc(const char* value, size_t size) {
  set_has_pdesc();
  if (pdesc_ == &::google::protobuf::internal::kEmptyString) {
    pdesc_ = new ::std::string;
  }
  pdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchInfo::mutable_pdesc() {
  set_has_pdesc();
  if (pdesc_ == &::google::protobuf::internal::kEmptyString) {
    pdesc_ = new ::std::string;
  }
  return pdesc_;
}
inline ::std::string* SearchInfo::release_pdesc() {
  clear_has_pdesc();
  if (pdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pdesc_;
    pdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchInfo::set_allocated_pdesc(::std::string* pdesc) {
  if (pdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete pdesc_;
  }
  if (pdesc) {
    set_has_pdesc();
    pdesc_ = pdesc;
  } else {
    clear_has_pdesc();
    pdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pgender = 14;
inline bool SearchInfo::has_pgender() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SearchInfo::set_has_pgender() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SearchInfo::clear_has_pgender() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SearchInfo::clear_pgender() {
  pgender_ = 0;
  clear_has_pgender();
}
inline ::google::protobuf::int32 SearchInfo::pgender() const {
  return pgender_;
}
inline void SearchInfo::set_pgender(::google::protobuf::int32 value) {
  set_has_pgender();
  pgender_ = value;
}

// optional string spacing = 15;
inline bool SearchInfo::has_spacing() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SearchInfo::set_has_spacing() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SearchInfo::clear_has_spacing() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SearchInfo::clear_spacing() {
  if (spacing_ != &::google::protobuf::internal::kEmptyString) {
    spacing_->clear();
  }
  clear_has_spacing();
}
inline const ::std::string& SearchInfo::spacing() const {
  return *spacing_;
}
inline void SearchInfo::set_spacing(const ::std::string& value) {
  set_has_spacing();
  if (spacing_ == &::google::protobuf::internal::kEmptyString) {
    spacing_ = new ::std::string;
  }
  spacing_->assign(value);
}
inline void SearchInfo::set_spacing(const char* value) {
  set_has_spacing();
  if (spacing_ == &::google::protobuf::internal::kEmptyString) {
    spacing_ = new ::std::string;
  }
  spacing_->assign(value);
}
inline void SearchInfo::set_spacing(const char* value, size_t size) {
  set_has_spacing();
  if (spacing_ == &::google::protobuf::internal::kEmptyString) {
    spacing_ = new ::std::string;
  }
  spacing_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchInfo::mutable_spacing() {
  set_has_spacing();
  if (spacing_ == &::google::protobuf::internal::kEmptyString) {
    spacing_ = new ::std::string;
  }
  return spacing_;
}
inline ::std::string* SearchInfo::release_spacing() {
  clear_has_spacing();
  if (spacing_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spacing_;
    spacing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchInfo::set_allocated_spacing(::std::string* spacing) {
  if (spacing_ != &::google::protobuf::internal::kEmptyString) {
    delete spacing_;
  }
  if (spacing) {
    set_has_spacing();
    spacing_ = spacing;
  } else {
    clear_has_spacing();
    spacing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cloudbox.protobuf.ImageInfo backgroundClip = 16;
inline bool SearchInfo::has_backgroundclip() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SearchInfo::set_has_backgroundclip() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SearchInfo::clear_has_backgroundclip() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SearchInfo::clear_backgroundclip() {
  if (backgroundclip_ != NULL) backgroundclip_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_backgroundclip();
}
inline const ::cloudbox::protobuf::ImageInfo& SearchInfo::backgroundclip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundclip_ != NULL ? *backgroundclip_ : *default_instance().backgroundclip_;
#else
  return backgroundclip_ != NULL ? *backgroundclip_ : *default_instance_->backgroundclip_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* SearchInfo::mutable_backgroundclip() {
  set_has_backgroundclip();
  if (backgroundclip_ == NULL) backgroundclip_ = new ::cloudbox::protobuf::ImageInfo;
  return backgroundclip_;
}
inline ::cloudbox::protobuf::ImageInfo* SearchInfo::release_backgroundclip() {
  clear_has_backgroundclip();
  ::cloudbox::protobuf::ImageInfo* temp = backgroundclip_;
  backgroundclip_ = NULL;
  return temp;
}
inline void SearchInfo::set_allocated_backgroundclip(::cloudbox::protobuf::ImageInfo* backgroundclip) {
  delete backgroundclip_;
  backgroundclip_ = backgroundclip;
  if (backgroundclip) {
    set_has_backgroundclip();
  } else {
    clear_has_backgroundclip();
  }
}

// optional int32 backgroundClipX = 17;
inline bool SearchInfo::has_backgroundclipx() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SearchInfo::set_has_backgroundclipx() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SearchInfo::clear_has_backgroundclipx() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SearchInfo::clear_backgroundclipx() {
  backgroundclipx_ = 0;
  clear_has_backgroundclipx();
}
inline ::google::protobuf::int32 SearchInfo::backgroundclipx() const {
  return backgroundclipx_;
}
inline void SearchInfo::set_backgroundclipx(::google::protobuf::int32 value) {
  set_has_backgroundclipx();
  backgroundclipx_ = value;
}

// optional int32 backgroundClipY = 18;
inline bool SearchInfo::has_backgroundclipy() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SearchInfo::set_has_backgroundclipy() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SearchInfo::clear_has_backgroundclipy() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SearchInfo::clear_backgroundclipy() {
  backgroundclipy_ = 0;
  clear_has_backgroundclipy();
}
inline ::google::protobuf::int32 SearchInfo::backgroundclipy() const {
  return backgroundclipy_;
}
inline void SearchInfo::set_backgroundclipy(::google::protobuf::int32 value) {
  set_has_backgroundclipy();
  backgroundclipy_ = value;
}

// optional int32 boxWidth = 19;
inline bool SearchInfo::has_boxwidth() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SearchInfo::set_has_boxwidth() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SearchInfo::clear_has_boxwidth() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SearchInfo::clear_boxwidth() {
  boxwidth_ = 0;
  clear_has_boxwidth();
}
inline ::google::protobuf::int32 SearchInfo::boxwidth() const {
  return boxwidth_;
}
inline void SearchInfo::set_boxwidth(::google::protobuf::int32 value) {
  set_has_boxwidth();
  boxwidth_ = value;
}

// optional int32 boxHeight = 20;
inline bool SearchInfo::has_boxheight() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SearchInfo::set_has_boxheight() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SearchInfo::clear_has_boxheight() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SearchInfo::clear_boxheight() {
  boxheight_ = 0;
  clear_has_boxheight();
}
inline ::google::protobuf::int32 SearchInfo::boxheight() const {
  return boxheight_;
}
inline void SearchInfo::set_boxheight(::google::protobuf::int32 value) {
  set_has_boxheight();
  boxheight_ = value;
}

// optional float offsetX = 21;
inline bool SearchInfo::has_offsetx() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SearchInfo::set_has_offsetx() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SearchInfo::clear_has_offsetx() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SearchInfo::clear_offsetx() {
  offsetx_ = 0;
  clear_has_offsetx();
}
inline float SearchInfo::offsetx() const {
  return offsetx_;
}
inline void SearchInfo::set_offsetx(float value) {
  set_has_offsetx();
  offsetx_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace cloudbox

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_searchinfo_5fresponse_2eproto__INCLUDED
