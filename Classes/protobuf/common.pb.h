// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace cloudbox {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class TargetInfo;
class ImageInfo;
class IconInfo;
class BoxColorInfo;
class EffectInfo;
class LineInfo;
class LineInfo_Split;
class BoxInfo;
class PlayUrlInfo;
class PlaySiteInfo;

enum TargetInfo_Type {
  TargetInfo_Type_OVERLAY = 0,
  TargetInfo_Type_FRAME = 1,
  TargetInfo_Type_PLAY = 2,
  TargetInfo_Type_SETTING = 3,
  TargetInfo_Type_SEARCH = 4,
  TargetInfo_Type_RECENTVIEW = 5,
  TargetInfo_Type_FAV = 6,
  TargetInfo_Type_LISTFAVS = 7,
  TargetInfo_Type_FILTER = 8,
  TargetInfo_Type_DIALOG = 9,
  TargetInfo_Type_HOTPROGRAMS = 10,
  TargetInfo_Type_LIVE = 11,
  TargetInfo_Type_CHECKUPDATE = 12,
  TargetInfo_Type_LAUNCHAPP = 13,
  TargetInfo_Type_LISTAPP = 14,
  TargetInfo_Type_RESET = 15,
  TargetInfo_Type_QUIT = 16,
  TargetInfo_Type_BAIDULOGIN = 17,
  TargetInfo_Type_BAIDUDIMCODELOGIN = 18,
  TargetInfo_Type_BAIDULIST = 19,
  TargetInfo_Type_CHANNELMANAGE = 20,
  TargetInfo_Type_CHANNELADD = 21
};
bool TargetInfo_Type_IsValid(int value);
const TargetInfo_Type TargetInfo_Type_Type_MIN = TargetInfo_Type_OVERLAY;
const TargetInfo_Type TargetInfo_Type_Type_MAX = TargetInfo_Type_CHANNELADD;
const int TargetInfo_Type_Type_ARRAYSIZE = TargetInfo_Type_Type_MAX + 1;

enum TargetInfo_FrameType {
  TargetInfo_FrameType_HOME = 0,
  TargetInfo_FrameType_LISTs = 1,
  TargetInfo_FrameType_DETAIL = 2
};
bool TargetInfo_FrameType_IsValid(int value);
const TargetInfo_FrameType TargetInfo_FrameType_FrameType_MIN = TargetInfo_FrameType_HOME;
const TargetInfo_FrameType TargetInfo_FrameType_FrameType_MAX = TargetInfo_FrameType_DETAIL;
const int TargetInfo_FrameType_FrameType_ARRAYSIZE = TargetInfo_FrameType_FrameType_MAX + 1;

enum LineInfo_Split_Direction {
  LineInfo_Split_Direction_LEFTTORIGHT = 0,
  LineInfo_Split_Direction_RIGHTTOLEFT = 1
};
bool LineInfo_Split_Direction_IsValid(int value);
const LineInfo_Split_Direction LineInfo_Split_Direction_Direction_MIN = LineInfo_Split_Direction_LEFTTORIGHT;
const LineInfo_Split_Direction LineInfo_Split_Direction_Direction_MAX = LineInfo_Split_Direction_RIGHTTOLEFT;
const int LineInfo_Split_Direction_Direction_ARRAYSIZE = LineInfo_Split_Direction_Direction_MAX + 1;

enum LineInfo_Type {
  LineInfo_Type_SINGLE = 0,
  LineInfo_Type_KEYVALUES = 1,
  LineInfo_Type_SPLIT = 2
};
bool LineInfo_Type_IsValid(int value);
const LineInfo_Type LineInfo_Type_Type_MIN = LineInfo_Type_SINGLE;
const LineInfo_Type LineInfo_Type_Type_MAX = LineInfo_Type_SPLIT;
const int LineInfo_Type_Type_ARRAYSIZE = LineInfo_Type_Type_MAX + 1;

enum BoxInfo_Type {
  BoxInfo_Type_INVALID = 0,
  BoxInfo_Type_ACTION = 1,
  BoxInfo_Type_VIDEO = 2,
  BoxInfo_Type_IMAGETEXT = 3,
  BoxInfo_Type_IMAGE = 4,
  BoxInfo_Type_SCROLL = 5,
  BoxInfo_Type_SEARCH = 6,
  BoxInfo_Type_LASTVIEW = 7,
  BoxInfo_Type_FAV = 8,
  BoxInfo_Type_RANK = 9,
  BoxInfo_Type_FILTER = 10,
  BoxInfo_Type_TEXT = 11,
  BoxInfo_Type_IMAGESTAR = 12,
  BoxInfo_Type_DOUBLELINE = 13,
  BoxInfo_Type_GRAYDOUBLELINE = 14,
  BoxInfo_Type_DESCRIPTION = 15,
  BoxInfo_Type_FOOTERBOTTON = 16,
  BoxInfo_Type_LIVE = 17,
  BoxInfo_Type_APPBOX = 18,
  BoxInfo_Type_USERPREFILE = 19,
  BoxInfo_Type_USERFUND = 20,
  BoxInfo_Type_USERTOP = 21,
  BoxInfo_Type_USERGAME = 22
};
bool BoxInfo_Type_IsValid(int value);
const BoxInfo_Type BoxInfo_Type_Type_MIN = BoxInfo_Type_INVALID;
const BoxInfo_Type BoxInfo_Type_Type_MAX = BoxInfo_Type_USERGAME;
const int BoxInfo_Type_Type_ARRAYSIZE = BoxInfo_Type_Type_MAX + 1;

enum BoxInfo_Tag {
  BoxInfo_Tag_NORMAL = 1,
  BoxInfo_Tag_DISABLED = 2,
  BoxInfo_Tag_CHECKFAV = 3,
  BoxInfo_Tag_ACTFAV = 4,
  BoxInfo_Tag_PLAY = 5,
  BoxInfo_Tag_SELECTEPISODE = 6
};
bool BoxInfo_Tag_IsValid(int value);
const BoxInfo_Tag BoxInfo_Tag_Tag_MIN = BoxInfo_Tag_NORMAL;
const BoxInfo_Tag BoxInfo_Tag_Tag_MAX = BoxInfo_Tag_SELECTEPISODE;
const int BoxInfo_Tag_Tag_ARRAYSIZE = BoxInfo_Tag_Tag_MAX + 1;

// ===================================================================

class TargetInfo : public ::google::protobuf::MessageLite {
 public:
  TargetInfo();
  virtual ~TargetInfo();

  TargetInfo(const TargetInfo& from);

  inline TargetInfo& operator=(const TargetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TargetInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TargetInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TargetInfo* other);

  // implements Message ----------------------------------------------

  TargetInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TargetInfo& from);
  void MergeFrom(const TargetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TargetInfo_Type Type;
  static const Type OVERLAY = TargetInfo_Type_OVERLAY;
  static const Type FRAME = TargetInfo_Type_FRAME;
  static const Type PLAY = TargetInfo_Type_PLAY;
  static const Type SETTING = TargetInfo_Type_SETTING;
  static const Type SEARCH = TargetInfo_Type_SEARCH;
  static const Type RECENTVIEW = TargetInfo_Type_RECENTVIEW;
  static const Type FAV = TargetInfo_Type_FAV;
  static const Type LISTFAVS = TargetInfo_Type_LISTFAVS;
  static const Type FILTER = TargetInfo_Type_FILTER;
  static const Type DIALOG = TargetInfo_Type_DIALOG;
  static const Type HOTPROGRAMS = TargetInfo_Type_HOTPROGRAMS;
  static const Type LIVE = TargetInfo_Type_LIVE;
  static const Type CHECKUPDATE = TargetInfo_Type_CHECKUPDATE;
  static const Type LAUNCHAPP = TargetInfo_Type_LAUNCHAPP;
  static const Type LISTAPP = TargetInfo_Type_LISTAPP;
  static const Type RESET = TargetInfo_Type_RESET;
  static const Type QUIT = TargetInfo_Type_QUIT;
  static const Type BAIDULOGIN = TargetInfo_Type_BAIDULOGIN;
  static const Type BAIDUDIMCODELOGIN = TargetInfo_Type_BAIDUDIMCODELOGIN;
  static const Type BAIDULIST = TargetInfo_Type_BAIDULIST;
  static const Type CHANNELMANAGE = TargetInfo_Type_CHANNELMANAGE;
  static const Type CHANNELADD = TargetInfo_Type_CHANNELADD;
  static inline bool Type_IsValid(int value) {
    return TargetInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TargetInfo_Type_Type_MIN;
  static const Type Type_MAX =
    TargetInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TargetInfo_Type_Type_ARRAYSIZE;

  typedef TargetInfo_FrameType FrameType;
  static const FrameType HOME = TargetInfo_FrameType_HOME;
  static const FrameType LISTs = TargetInfo_FrameType_LISTs;
  static const FrameType DETAIL = TargetInfo_FrameType_DETAIL;
  static inline bool FrameType_IsValid(int value) {
    return TargetInfo_FrameType_IsValid(value);
  }
  static const FrameType FrameType_MIN =
    TargetInfo_FrameType_FrameType_MIN;
  static const FrameType FrameType_MAX =
    TargetInfo_FrameType_FrameType_MAX;
  static const int FrameType_ARRAYSIZE =
    TargetInfo_FrameType_FrameType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .cloudbox.protobuf.TargetInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::cloudbox::protobuf::TargetInfo_Type type() const;
  inline void set_type(::cloudbox::protobuf::TargetInfo_Type value);

  // optional .cloudbox.protobuf.TargetInfo.FrameType frameType = 2;
  inline bool has_frametype() const;
  inline void clear_frametype();
  static const int kFrameTypeFieldNumber = 2;
  inline ::cloudbox::protobuf::TargetInfo_FrameType frametype() const;
  inline void set_frametype(::cloudbox::protobuf::TargetInfo_FrameType value);

  // optional string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional int32 leftNavShow = 6;
  inline bool has_leftnavshow() const;
  inline void clear_leftnavshow();
  static const int kLeftNavShowFieldNumber = 6;
  inline ::google::protobuf::int32 leftnavshow() const;
  inline void set_leftnavshow(::google::protobuf::int32 value);

  // optional int32 leftNavFocus = 7;
  inline bool has_leftnavfocus() const;
  inline void clear_leftnavfocus();
  static const int kLeftNavFocusFieldNumber = 7;
  inline ::google::protobuf::int32 leftnavfocus() const;
  inline void set_leftnavfocus(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.TargetInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_frametype();
  inline void clear_has_frametype();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_leftnavshow();
  inline void clear_has_leftnavshow();
  inline void set_has_leftnavfocus();
  inline void clear_has_leftnavfocus();

  int type_;
  int frametype_;
  ::std::string* data_;
  ::std::string* channel_;
  ::google::protobuf::int32 leftnavshow_;
  ::google::protobuf::int32 leftnavfocus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TargetInfo* default_instance_;
};
// -------------------------------------------------------------------

class ImageInfo : public ::google::protobuf::MessageLite {
 public:
  ImageInfo();
  virtual ~ImageInfo();

  ImageInfo(const ImageInfo& from);

  inline ImageInfo& operator=(const ImageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ImageInfo* other);

  // implements Message ----------------------------------------------

  ImageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageInfo& from);
  void MergeFrom(const ImageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline float width() const;
  inline void set_width(float value);

  // optional float height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline float height() const;
  inline void set_height(float value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.ImageInfo)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_url();
  inline void clear_has_url();

  float width_;
  float height_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ImageInfo* default_instance_;
};
// -------------------------------------------------------------------

class IconInfo : public ::google::protobuf::MessageLite {
 public:
  IconInfo();
  virtual ~IconInfo();

  IconInfo(const IconInfo& from);

  inline IconInfo& operator=(const IconInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const IconInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IconInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IconInfo* other);

  // implements Message ----------------------------------------------

  IconInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IconInfo& from);
  void MergeFrom(const IconInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline float width() const;
  inline void set_width(float value);

  // optional float height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline float height() const;
  inline void set_height(float value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  inline const ::std::string& direction() const;
  inline void set_direction(const ::std::string& value);
  inline void set_direction(const char* value);
  inline void set_direction(const char* value, size_t size);
  inline ::std::string* mutable_direction();
  inline ::std::string* release_direction();
  inline void set_allocated_direction(::std::string* direction);

  // optional float offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline float offset() const;
  inline void set_offset(float value);

  // optional .cloudbox.protobuf.TargetInfo target = 6;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 6;
  inline const ::cloudbox::protobuf::TargetInfo& target() const;
  inline ::cloudbox::protobuf::TargetInfo* mutable_target();
  inline ::cloudbox::protobuf::TargetInfo* release_target();
  inline void set_allocated_target(::cloudbox::protobuf::TargetInfo* target);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.IconInfo)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_target();
  inline void clear_has_target();

  float width_;
  float height_;
  ::std::string* url_;
  ::std::string* direction_;
  ::cloudbox::protobuf::TargetInfo* target_;
  float offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static IconInfo* default_instance_;
};
// -------------------------------------------------------------------

class BoxColorInfo : public ::google::protobuf::MessageLite {
 public:
  BoxColorInfo();
  virtual ~BoxColorInfo();

  BoxColorInfo(const BoxColorInfo& from);

  inline BoxColorInfo& operator=(const BoxColorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BoxColorInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BoxColorInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BoxColorInfo* other);

  // implements Message ----------------------------------------------

  BoxColorInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BoxColorInfo& from);
  void MergeFrom(const BoxColorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 red = 1;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 1;
  inline ::google::protobuf::int32 red() const;
  inline void set_red(::google::protobuf::int32 value);

  // optional int32 green = 2;
  inline bool has_green() const;
  inline void clear_green();
  static const int kGreenFieldNumber = 2;
  inline ::google::protobuf::int32 green() const;
  inline void set_green(::google::protobuf::int32 value);

  // optional int32 blue = 3;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 3;
  inline ::google::protobuf::int32 blue() const;
  inline void set_blue(::google::protobuf::int32 value);

  // optional int32 alpha = 4;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 4;
  inline ::google::protobuf::int32 alpha() const;
  inline void set_alpha(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.BoxColorInfo)
 private:
  inline void set_has_red();
  inline void clear_has_red();
  inline void set_has_green();
  inline void clear_has_green();
  inline void set_has_blue();
  inline void clear_has_blue();
  inline void set_has_alpha();
  inline void clear_has_alpha();

  ::google::protobuf::int32 red_;
  ::google::protobuf::int32 green_;
  ::google::protobuf::int32 blue_;
  ::google::protobuf::int32 alpha_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BoxColorInfo* default_instance_;
};
// -------------------------------------------------------------------

class EffectInfo : public ::google::protobuf::MessageLite {
 public:
  EffectInfo();
  virtual ~EffectInfo();

  EffectInfo(const EffectInfo& from);

  inline EffectInfo& operator=(const EffectInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const EffectInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EffectInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EffectInfo* other);

  // implements Message ----------------------------------------------

  EffectInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EffectInfo& from);
  void MergeFrom(const EffectInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 interval = 1;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 1;
  inline ::google::protobuf::int32 interval() const;
  inline void set_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.EffectInfo)
 private:
  inline void set_has_interval();
  inline void clear_has_interval();

  ::google::protobuf::int32 interval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static EffectInfo* default_instance_;
};
// -------------------------------------------------------------------

class LineInfo_Split : public ::google::protobuf::MessageLite {
 public:
  LineInfo_Split();
  virtual ~LineInfo_Split();

  LineInfo_Split(const LineInfo_Split& from);

  inline LineInfo_Split& operator=(const LineInfo_Split& from) {
    CopyFrom(from);
    return *this;
  }

  static const LineInfo_Split& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LineInfo_Split* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LineInfo_Split* other);

  // implements Message ----------------------------------------------

  LineInfo_Split* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LineInfo_Split& from);
  void MergeFrom(const LineInfo_Split& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LineInfo_Split_Direction Direction;
  static const Direction LEFTTORIGHT = LineInfo_Split_Direction_LEFTTORIGHT;
  static const Direction RIGHTTOLEFT = LineInfo_Split_Direction_RIGHTTOLEFT;
  static inline bool Direction_IsValid(int value) {
    return LineInfo_Split_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    LineInfo_Split_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    LineInfo_Split_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    LineInfo_Split_Direction_Direction_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .cloudbox.protobuf.ImageInfo img = 1;
  inline bool has_img() const;
  inline void clear_img();
  static const int kImgFieldNumber = 1;
  inline const ::cloudbox::protobuf::ImageInfo& img() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_img();
  inline ::cloudbox::protobuf::ImageInfo* release_img();
  inline void set_allocated_img(::cloudbox::protobuf::ImageInfo* img);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.LineInfo.Split)
 private:
  inline void set_has_img();
  inline void clear_has_img();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();

  ::cloudbox::protobuf::ImageInfo* img_;
  ::std::string* name_;
  ::google::protobuf::int32 score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LineInfo_Split* default_instance_;
};
// -------------------------------------------------------------------

class LineInfo : public ::google::protobuf::MessageLite {
 public:
  LineInfo();
  virtual ~LineInfo();

  LineInfo(const LineInfo& from);

  inline LineInfo& operator=(const LineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LineInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LineInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LineInfo* other);

  // implements Message ----------------------------------------------

  LineInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LineInfo& from);
  void MergeFrom(const LineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LineInfo_Split Split;

  typedef LineInfo_Type Type;
  static const Type SINGLE = LineInfo_Type_SINGLE;
  static const Type KEYVALUES = LineInfo_Type_KEYVALUES;
  static const Type SPLIT = LineInfo_Type_SPLIT;
  static inline bool Type_IsValid(int value) {
    return LineInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LineInfo_Type_Type_MIN;
  static const Type Type_MAX =
    LineInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LineInfo_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .cloudbox.protobuf.LineInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::cloudbox::protobuf::LineInfo_Type type() const;
  inline void set_type(::cloudbox::protobuf::LineInfo_Type value);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // repeated string values = 3;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 3;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // optional .cloudbox.protobuf.LineInfo.Split left = 4;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 4;
  inline const ::cloudbox::protobuf::LineInfo_Split& left() const;
  inline ::cloudbox::protobuf::LineInfo_Split* mutable_left();
  inline ::cloudbox::protobuf::LineInfo_Split* release_left();
  inline void set_allocated_left(::cloudbox::protobuf::LineInfo_Split* left);

  // optional .cloudbox.protobuf.LineInfo.Split right = 5;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 5;
  inline const ::cloudbox::protobuf::LineInfo_Split& right() const;
  inline ::cloudbox::protobuf::LineInfo_Split* mutable_right();
  inline ::cloudbox::protobuf::LineInfo_Split* release_right();
  inline void set_allocated_right(::cloudbox::protobuf::LineInfo_Split* right);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.LineInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();

  ::std::string* key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::cloudbox::protobuf::LineInfo_Split* left_;
  ::cloudbox::protobuf::LineInfo_Split* right_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LineInfo* default_instance_;
};
// -------------------------------------------------------------------

class BoxInfo : public ::google::protobuf::MessageLite {
 public:
  BoxInfo();
  virtual ~BoxInfo();

  BoxInfo(const BoxInfo& from);

  inline BoxInfo& operator=(const BoxInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BoxInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BoxInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BoxInfo* other);

  // implements Message ----------------------------------------------

  BoxInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BoxInfo& from);
  void MergeFrom(const BoxInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BoxInfo_Type Type;
  static const Type INVALID = BoxInfo_Type_INVALID;
  static const Type ACTION = BoxInfo_Type_ACTION;
  static const Type VIDEO = BoxInfo_Type_VIDEO;
  static const Type IMAGETEXT = BoxInfo_Type_IMAGETEXT;
  static const Type IMAGE = BoxInfo_Type_IMAGE;
  static const Type SCROLL = BoxInfo_Type_SCROLL;
  static const Type SEARCH = BoxInfo_Type_SEARCH;
  static const Type LASTVIEW = BoxInfo_Type_LASTVIEW;
  static const Type FAV = BoxInfo_Type_FAV;
  static const Type RANK = BoxInfo_Type_RANK;
  static const Type FILTER = BoxInfo_Type_FILTER;
  static const Type TEXT = BoxInfo_Type_TEXT;
  static const Type IMAGESTAR = BoxInfo_Type_IMAGESTAR;
  static const Type DOUBLELINE = BoxInfo_Type_DOUBLELINE;
  static const Type GRAYDOUBLELINE = BoxInfo_Type_GRAYDOUBLELINE;
  static const Type DESCRIPTION = BoxInfo_Type_DESCRIPTION;
  static const Type FOOTERBOTTON = BoxInfo_Type_FOOTERBOTTON;
  static const Type LIVE = BoxInfo_Type_LIVE;
  static const Type APPBOX = BoxInfo_Type_APPBOX;
  static const Type USERPREFILE = BoxInfo_Type_USERPREFILE;
  static const Type USERFUND = BoxInfo_Type_USERFUND;
  static const Type USERTOP = BoxInfo_Type_USERTOP;
  static const Type USERGAME = BoxInfo_Type_USERGAME;
  static inline bool Type_IsValid(int value) {
    return BoxInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BoxInfo_Type_Type_MIN;
  static const Type Type_MAX =
    BoxInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BoxInfo_Type_Type_ARRAYSIZE;

  typedef BoxInfo_Tag Tag;
  static const Tag NORMAL = BoxInfo_Tag_NORMAL;
  static const Tag DISABLED = BoxInfo_Tag_DISABLED;
  static const Tag CHECKFAV = BoxInfo_Tag_CHECKFAV;
  static const Tag ACTFAV = BoxInfo_Tag_ACTFAV;
  static const Tag PLAY = BoxInfo_Tag_PLAY;
  static const Tag SELECTEPISODE = BoxInfo_Tag_SELECTEPISODE;
  static inline bool Tag_IsValid(int value) {
    return BoxInfo_Tag_IsValid(value);
  }
  static const Tag Tag_MIN =
    BoxInfo_Tag_Tag_MIN;
  static const Tag Tag_MAX =
    BoxInfo_Tag_Tag_MAX;
  static const int Tag_ARRAYSIZE =
    BoxInfo_Tag_Tag_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional float width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline float width() const;
  inline void set_width(float value);

  // optional float height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline float height() const;
  inline void set_height(float value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional .cloudbox.protobuf.ImageInfo img = 4;
  inline bool has_img() const;
  inline void clear_img();
  static const int kImgFieldNumber = 4;
  inline const ::cloudbox::protobuf::ImageInfo& img() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_img();
  inline ::cloudbox::protobuf::ImageInfo* release_img();
  inline void set_allocated_img(::cloudbox::protobuf::ImageInfo* img);

  // optional .cloudbox.protobuf.BoxInfo.Type type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::cloudbox::protobuf::BoxInfo_Type type() const;
  inline void set_type(::cloudbox::protobuf::BoxInfo_Type value);

  // optional int32 focusable = 6;
  inline bool has_focusable() const;
  inline void clear_focusable();
  static const int kFocusableFieldNumber = 6;
  inline ::google::protobuf::int32 focusable() const;
  inline void set_focusable(::google::protobuf::int32 value);

  // optional string channel = 7;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 7;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional string id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string title = 9;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 9;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string subTitle = 10;
  inline bool has_subtitle() const;
  inline void clear_subtitle();
  static const int kSubTitleFieldNumber = 10;
  inline const ::std::string& subtitle() const;
  inline void set_subtitle(const ::std::string& value);
  inline void set_subtitle(const char* value);
  inline void set_subtitle(const char* value, size_t size);
  inline ::std::string* mutable_subtitle();
  inline ::std::string* release_subtitle();
  inline void set_allocated_subtitle(::std::string* subtitle);

  // optional int32 score = 11;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 11;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 episode = 12;
  inline bool has_episode() const;
  inline void clear_episode();
  static const int kEpisodeFieldNumber = 12;
  inline ::google::protobuf::int32 episode() const;
  inline void set_episode(::google::protobuf::int32 value);

  // optional int32 totalEpisode = 13;
  inline bool has_totalepisode() const;
  inline void clear_totalepisode();
  static const int kTotalEpisodeFieldNumber = 13;
  inline ::google::protobuf::int32 totalepisode() const;
  inline void set_totalepisode(::google::protobuf::int32 value);

  // optional int32 isFinished = 14;
  inline bool has_isfinished() const;
  inline void clear_isfinished();
  static const int kIsFinishedFieldNumber = 14;
  inline ::google::protobuf::int32 isfinished() const;
  inline void set_isfinished(::google::protobuf::int32 value);

  // optional string description = 15;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 15;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated .cloudbox.protobuf.LineInfo lines = 16;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 16;
  inline const ::cloudbox::protobuf::LineInfo& lines(int index) const;
  inline ::cloudbox::protobuf::LineInfo* mutable_lines(int index);
  inline ::cloudbox::protobuf::LineInfo* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::LineInfo >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::LineInfo >*
      mutable_lines();

  // optional string format = 17;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 17;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // optional .cloudbox.protobuf.ImageInfo icon = 18;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 18;
  inline const ::cloudbox::protobuf::ImageInfo& icon() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_icon();
  inline ::cloudbox::protobuf::ImageInfo* release_icon();
  inline void set_allocated_icon(::cloudbox::protobuf::ImageInfo* icon);

  // optional int32 site = 19;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 19;
  inline ::google::protobuf::int32 site() const;
  inline void set_site(::google::protobuf::int32 value);

  // optional .cloudbox.protobuf.TargetInfo target = 20;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 20;
  inline const ::cloudbox::protobuf::TargetInfo& target() const;
  inline ::cloudbox::protobuf::TargetInfo* mutable_target();
  inline ::cloudbox::protobuf::TargetInfo* release_target();
  inline void set_allocated_target(::cloudbox::protobuf::TargetInfo* target);

  // optional int32 rank = 21;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 21;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional int32 length = 22;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 22;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional int32 totalLength = 23;
  inline bool has_totallength() const;
  inline void clear_totallength();
  static const int kTotalLengthFieldNumber = 23;
  inline ::google::protobuf::int32 totallength() const;
  inline void set_totallength(::google::protobuf::int32 value);

  // optional .cloudbox.protobuf.ImageInfo background = 24;
  inline bool has_background() const;
  inline void clear_background();
  static const int kBackgroundFieldNumber = 24;
  inline const ::cloudbox::protobuf::ImageInfo& background() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_background();
  inline ::cloudbox::protobuf::ImageInfo* release_background();
  inline void set_allocated_background(::cloudbox::protobuf::ImageInfo* background);

  // optional .cloudbox.protobuf.BoxInfo.Tag tag = 25;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 25;
  inline ::cloudbox::protobuf::BoxInfo_Tag tag() const;
  inline void set_tag(::cloudbox::protobuf::BoxInfo_Tag value);

  // optional string siteName = 26;
  inline bool has_sitename() const;
  inline void clear_sitename();
  static const int kSiteNameFieldNumber = 26;
  inline const ::std::string& sitename() const;
  inline void set_sitename(const ::std::string& value);
  inline void set_sitename(const char* value);
  inline void set_sitename(const char* value, size_t size);
  inline ::std::string* mutable_sitename();
  inline ::std::string* release_sitename();
  inline void set_allocated_sitename(::std::string* sitename);

  // optional int32 updated = 27;
  inline bool has_updated() const;
  inline void clear_updated();
  static const int kUpdatedFieldNumber = 27;
  inline ::google::protobuf::int32 updated() const;
  inline void set_updated(::google::protobuf::int32 value);

  // optional bytes appIcon = 28;
  inline bool has_appicon() const;
  inline void clear_appicon();
  static const int kAppIconFieldNumber = 28;
  inline const ::std::string& appicon() const;
  inline void set_appicon(const ::std::string& value);
  inline void set_appicon(const char* value);
  inline void set_appicon(const void* value, size_t size);
  inline ::std::string* mutable_appicon();
  inline ::std::string* release_appicon();
  inline void set_allocated_appicon(::std::string* appicon);

  // optional string stage = 29;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 29;
  inline const ::std::string& stage() const;
  inline void set_stage(const ::std::string& value);
  inline void set_stage(const char* value);
  inline void set_stage(const char* value, size_t size);
  inline ::std::string* mutable_stage();
  inline ::std::string* release_stage();
  inline void set_allocated_stage(::std::string* stage);

  // optional int32 playNum = 30;
  inline bool has_playnum() const;
  inline void clear_playnum();
  static const int kPlayNumFieldNumber = 30;
  inline ::google::protobuf::int32 playnum() const;
  inline void set_playnum(::google::protobuf::int32 value);

  // optional string playNumTitle = 31;
  inline bool has_playnumtitle() const;
  inline void clear_playnumtitle();
  static const int kPlayNumTitleFieldNumber = 31;
  inline const ::std::string& playnumtitle() const;
  inline void set_playnumtitle(const ::std::string& value);
  inline void set_playnumtitle(const char* value);
  inline void set_playnumtitle(const char* value, size_t size);
  inline ::std::string* mutable_playnumtitle();
  inline ::std::string* release_playnumtitle();
  inline void set_allocated_playnumtitle(::std::string* playnumtitle);

  // optional .cloudbox.protobuf.ImageInfo mImg = 32;
  inline bool has_mimg() const;
  inline void clear_mimg();
  static const int kMImgFieldNumber = 32;
  inline const ::cloudbox::protobuf::ImageInfo& mimg() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_mimg();
  inline ::cloudbox::protobuf::ImageInfo* release_mimg();
  inline void set_allocated_mimg(::cloudbox::protobuf::ImageInfo* mimg);

  // optional int32 ts = 33;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 33;
  inline ::google::protobuf::int32 ts() const;
  inline void set_ts(::google::protobuf::int32 value);

  // optional .cloudbox.protobuf.ImageInfo fixedImg = 34;
  inline bool has_fixedimg() const;
  inline void clear_fixedimg();
  static const int kFixedImgFieldNumber = 34;
  inline const ::cloudbox::protobuf::ImageInfo& fixedimg() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_fixedimg();
  inline ::cloudbox::protobuf::ImageInfo* release_fixedimg();
  inline void set_allocated_fixedimg(::cloudbox::protobuf::ImageInfo* fixedimg);

  // optional int32 showTitle = 35;
  inline bool has_showtitle() const;
  inline void clear_showtitle();
  static const int kShowTitleFieldNumber = 35;
  inline ::google::protobuf::int32 showtitle() const;
  inline void set_showtitle(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.IconInfo icons = 36;
  inline int icons_size() const;
  inline void clear_icons();
  static const int kIconsFieldNumber = 36;
  inline const ::cloudbox::protobuf::IconInfo& icons(int index) const;
  inline ::cloudbox::protobuf::IconInfo* mutable_icons(int index);
  inline ::cloudbox::protobuf::IconInfo* add_icons();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::IconInfo >&
      icons() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::IconInfo >*
      mutable_icons();

  // optional int32 effectType = 37;
  inline bool has_effecttype() const;
  inline void clear_effecttype();
  static const int kEffectTypeFieldNumber = 37;
  inline ::google::protobuf::int32 effecttype() const;
  inline void set_effecttype(::google::protobuf::int32 value);

  // optional .cloudbox.protobuf.EffectInfo effectInfo = 38;
  inline bool has_effectinfo() const;
  inline void clear_effectinfo();
  static const int kEffectInfoFieldNumber = 38;
  inline const ::cloudbox::protobuf::EffectInfo& effectinfo() const;
  inline ::cloudbox::protobuf::EffectInfo* mutable_effectinfo();
  inline ::cloudbox::protobuf::EffectInfo* release_effectinfo();
  inline void set_allocated_effectinfo(::cloudbox::protobuf::EffectInfo* effectinfo);

  // optional int32 spacing = 39;
  inline bool has_spacing() const;
  inline void clear_spacing();
  static const int kSpacingFieldNumber = 39;
  inline ::google::protobuf::int32 spacing() const;
  inline void set_spacing(::google::protobuf::int32 value);

  // optional .cloudbox.protobuf.BoxColorInfo boxColor = 40;
  inline bool has_boxcolor() const;
  inline void clear_boxcolor();
  static const int kBoxColorFieldNumber = 40;
  inline const ::cloudbox::protobuf::BoxColorInfo& boxcolor() const;
  inline ::cloudbox::protobuf::BoxColorInfo* mutable_boxcolor();
  inline ::cloudbox::protobuf::BoxColorInfo* release_boxcolor();
  inline void set_allocated_boxcolor(::cloudbox::protobuf::BoxColorInfo* boxcolor);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.BoxInfo)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_img();
  inline void clear_has_img();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_focusable();
  inline void clear_has_focusable();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_subtitle();
  inline void clear_has_subtitle();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_episode();
  inline void clear_has_episode();
  inline void set_has_totalepisode();
  inline void clear_has_totalepisode();
  inline void set_has_isfinished();
  inline void clear_has_isfinished();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_totallength();
  inline void clear_has_totallength();
  inline void set_has_background();
  inline void clear_has_background();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_sitename();
  inline void clear_has_sitename();
  inline void set_has_updated();
  inline void clear_has_updated();
  inline void set_has_appicon();
  inline void clear_has_appicon();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_playnum();
  inline void clear_has_playnum();
  inline void set_has_playnumtitle();
  inline void clear_has_playnumtitle();
  inline void set_has_mimg();
  inline void clear_has_mimg();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_fixedimg();
  inline void clear_has_fixedimg();
  inline void set_has_showtitle();
  inline void clear_has_showtitle();
  inline void set_has_effecttype();
  inline void clear_has_effecttype();
  inline void set_has_effectinfo();
  inline void clear_has_effectinfo();
  inline void set_has_spacing();
  inline void clear_has_spacing();
  inline void set_has_boxcolor();
  inline void clear_has_boxcolor();

  float width_;
  float height_;
  ::std::string* url_;
  ::cloudbox::protobuf::ImageInfo* img_;
  int type_;
  ::google::protobuf::int32 focusable_;
  ::std::string* channel_;
  ::std::string* id_;
  ::std::string* title_;
  ::std::string* subtitle_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 episode_;
  ::google::protobuf::int32 totalepisode_;
  ::google::protobuf::int32 isfinished_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::LineInfo > lines_;
  ::std::string* format_;
  ::cloudbox::protobuf::ImageInfo* icon_;
  ::cloudbox::protobuf::TargetInfo* target_;
  ::google::protobuf::int32 site_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 length_;
  ::google::protobuf::int32 totallength_;
  ::cloudbox::protobuf::ImageInfo* background_;
  ::std::string* sitename_;
  int tag_;
  ::google::protobuf::int32 updated_;
  ::std::string* appicon_;
  ::std::string* stage_;
  ::std::string* playnumtitle_;
  ::google::protobuf::int32 playnum_;
  ::google::protobuf::int32 ts_;
  ::cloudbox::protobuf::ImageInfo* mimg_;
  ::cloudbox::protobuf::ImageInfo* fixedimg_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::IconInfo > icons_;
  ::google::protobuf::int32 showtitle_;
  ::google::protobuf::int32 effecttype_;
  ::cloudbox::protobuf::EffectInfo* effectinfo_;
  ::cloudbox::protobuf::BoxColorInfo* boxcolor_;
  ::google::protobuf::int32 spacing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BoxInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayUrlInfo : public ::google::protobuf::MessageLite {
 public:
  PlayUrlInfo();
  virtual ~PlayUrlInfo();

  PlayUrlInfo(const PlayUrlInfo& from);

  inline PlayUrlInfo& operator=(const PlayUrlInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayUrlInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayUrlInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayUrlInfo* other);

  // implements Message ----------------------------------------------

  PlayUrlInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayUrlInfo& from);
  void MergeFrom(const PlayUrlInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string format = 1;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional float op = 3;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 3;
  inline float op() const;
  inline void set_op(float value);

  // optional float ed = 4;
  inline bool has_ed() const;
  inline void clear_ed();
  static const int kEdFieldNumber = 4;
  inline float ed() const;
  inline void set_ed(float value);

  // optional int32 urltype = 5;
  inline bool has_urltype() const;
  inline void clear_urltype();
  static const int kUrltypeFieldNumber = 5;
  inline ::google::protobuf::int32 urltype() const;
  inline void set_urltype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.PlayUrlInfo)
 private:
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_ed();
  inline void clear_has_ed();
  inline void set_has_urltype();
  inline void clear_has_urltype();

  ::std::string* format_;
  ::std::string* url_;
  float op_;
  float ed_;
  ::google::protobuf::int32 urltype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PlayUrlInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlaySiteInfo : public ::google::protobuf::MessageLite {
 public:
  PlaySiteInfo();
  virtual ~PlaySiteInfo();

  PlaySiteInfo(const PlaySiteInfo& from);

  inline PlaySiteInfo& operator=(const PlaySiteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlaySiteInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlaySiteInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlaySiteInfo* other);

  // implements Message ----------------------------------------------

  PlaySiteInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlaySiteInfo& from);
  void MergeFrom(const PlaySiteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 site = 1;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 1;
  inline ::google::protobuf::int32 site() const;
  inline void set_site(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.PlayUrlInfo urls = 5;
  inline int urls_size() const;
  inline void clear_urls();
  static const int kUrlsFieldNumber = 5;
  inline const ::cloudbox::protobuf::PlayUrlInfo& urls(int index) const;
  inline ::cloudbox::protobuf::PlayUrlInfo* mutable_urls(int index);
  inline ::cloudbox::protobuf::PlayUrlInfo* add_urls();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlayUrlInfo >&
      urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlayUrlInfo >*
      mutable_urls();

  // optional string title = 6;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 6;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional .cloudbox.protobuf.ImageInfo logo = 7;
  inline bool has_logo() const;
  inline void clear_logo();
  static const int kLogoFieldNumber = 7;
  inline const ::cloudbox::protobuf::ImageInfo& logo() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_logo();
  inline ::cloudbox::protobuf::ImageInfo* release_logo();
  inline void set_allocated_logo(::cloudbox::protobuf::ImageInfo* logo);

  // optional string luaInfo = 8;
  inline bool has_luainfo() const;
  inline void clear_luainfo();
  static const int kLuaInfoFieldNumber = 8;
  inline const ::std::string& luainfo() const;
  inline void set_luainfo(const ::std::string& value);
  inline void set_luainfo(const char* value);
  inline void set_luainfo(const char* value, size_t size);
  inline ::std::string* mutable_luainfo();
  inline ::std::string* release_luainfo();
  inline void set_allocated_luainfo(::std::string* luainfo);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.PlaySiteInfo)
 private:
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_logo();
  inline void clear_has_logo();
  inline void set_has_luainfo();
  inline void clear_has_luainfo();

  ::std::string* name_;
  ::google::protobuf::int32 site_;
  ::google::protobuf::int32 length_;
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlayUrlInfo > urls_;
  ::std::string* title_;
  ::cloudbox::protobuf::ImageInfo* logo_;
  ::std::string* luainfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PlaySiteInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// TargetInfo

// optional .cloudbox.protobuf.TargetInfo.Type type = 1;
inline bool TargetInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cloudbox::protobuf::TargetInfo_Type TargetInfo::type() const {
  return static_cast< ::cloudbox::protobuf::TargetInfo_Type >(type_);
}
inline void TargetInfo::set_type(::cloudbox::protobuf::TargetInfo_Type value) {
  assert(::cloudbox::protobuf::TargetInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .cloudbox.protobuf.TargetInfo.FrameType frameType = 2;
inline bool TargetInfo::has_frametype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetInfo::set_has_frametype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetInfo::clear_has_frametype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetInfo::clear_frametype() {
  frametype_ = 0;
  clear_has_frametype();
}
inline ::cloudbox::protobuf::TargetInfo_FrameType TargetInfo::frametype() const {
  return static_cast< ::cloudbox::protobuf::TargetInfo_FrameType >(frametype_);
}
inline void TargetInfo::set_frametype(::cloudbox::protobuf::TargetInfo_FrameType value) {
  assert(::cloudbox::protobuf::TargetInfo_FrameType_IsValid(value));
  set_has_frametype();
  frametype_ = value;
}

// optional string data = 3;
inline bool TargetInfo::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetInfo::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TargetInfo::data() const {
  return *data_;
}
inline void TargetInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TargetInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TargetInfo::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TargetInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 5;
inline bool TargetInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TargetInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TargetInfo::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& TargetInfo::channel() const {
  return *channel_;
}
inline void TargetInfo::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TargetInfo::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void TargetInfo::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetInfo::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* TargetInfo::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetInfo::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 leftNavShow = 6;
inline bool TargetInfo::has_leftnavshow() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TargetInfo::set_has_leftnavshow() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TargetInfo::clear_has_leftnavshow() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TargetInfo::clear_leftnavshow() {
  leftnavshow_ = 0;
  clear_has_leftnavshow();
}
inline ::google::protobuf::int32 TargetInfo::leftnavshow() const {
  return leftnavshow_;
}
inline void TargetInfo::set_leftnavshow(::google::protobuf::int32 value) {
  set_has_leftnavshow();
  leftnavshow_ = value;
}

// optional int32 leftNavFocus = 7;
inline bool TargetInfo::has_leftnavfocus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TargetInfo::set_has_leftnavfocus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TargetInfo::clear_has_leftnavfocus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TargetInfo::clear_leftnavfocus() {
  leftnavfocus_ = 0;
  clear_has_leftnavfocus();
}
inline ::google::protobuf::int32 TargetInfo::leftnavfocus() const {
  return leftnavfocus_;
}
inline void TargetInfo::set_leftnavfocus(::google::protobuf::int32 value) {
  set_has_leftnavfocus();
  leftnavfocus_ = value;
}

// -------------------------------------------------------------------

// ImageInfo

// optional float width = 1;
inline bool ImageInfo::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageInfo::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageInfo::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float ImageInfo::width() const {
  return width_;
}
inline void ImageInfo::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float height = 2;
inline bool ImageInfo::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageInfo::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageInfo::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float ImageInfo::height() const {
  return height_;
}
inline void ImageInfo::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional string url = 3;
inline bool ImageInfo::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageInfo::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ImageInfo::url() const {
  return *url_;
}
inline void ImageInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ImageInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ImageInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ImageInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageInfo::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IconInfo

// optional float width = 1;
inline bool IconInfo::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IconInfo::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IconInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IconInfo::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float IconInfo::width() const {
  return width_;
}
inline void IconInfo::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float height = 2;
inline bool IconInfo::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IconInfo::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IconInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IconInfo::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float IconInfo::height() const {
  return height_;
}
inline void IconInfo::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional string url = 3;
inline bool IconInfo::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IconInfo::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IconInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IconInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& IconInfo::url() const {
  return *url_;
}
inline void IconInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void IconInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void IconInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IconInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* IconInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IconInfo::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string direction = 4;
inline bool IconInfo::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IconInfo::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IconInfo::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IconInfo::clear_direction() {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    direction_->clear();
  }
  clear_has_direction();
}
inline const ::std::string& IconInfo::direction() const {
  return *direction_;
}
inline void IconInfo::set_direction(const ::std::string& value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void IconInfo::set_direction(const char* value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void IconInfo::set_direction(const char* value, size_t size) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IconInfo::mutable_direction() {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  return direction_;
}
inline ::std::string* IconInfo::release_direction() {
  clear_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direction_;
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IconInfo::set_allocated_direction(::std::string* direction) {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    delete direction_;
  }
  if (direction) {
    set_has_direction();
    direction_ = direction;
  } else {
    clear_has_direction();
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float offset = 5;
inline bool IconInfo::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IconInfo::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IconInfo::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IconInfo::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float IconInfo::offset() const {
  return offset_;
}
inline void IconInfo::set_offset(float value) {
  set_has_offset();
  offset_ = value;
}

// optional .cloudbox.protobuf.TargetInfo target = 6;
inline bool IconInfo::has_target() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IconInfo::set_has_target() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IconInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IconInfo::clear_target() {
  if (target_ != NULL) target_->::cloudbox::protobuf::TargetInfo::Clear();
  clear_has_target();
}
inline const ::cloudbox::protobuf::TargetInfo& IconInfo::target() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return target_ != NULL ? *target_ : *default_instance().target_;
#else
  return target_ != NULL ? *target_ : *default_instance_->target_;
#endif
}
inline ::cloudbox::protobuf::TargetInfo* IconInfo::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::cloudbox::protobuf::TargetInfo;
  return target_;
}
inline ::cloudbox::protobuf::TargetInfo* IconInfo::release_target() {
  clear_has_target();
  ::cloudbox::protobuf::TargetInfo* temp = target_;
  target_ = NULL;
  return temp;
}
inline void IconInfo::set_allocated_target(::cloudbox::protobuf::TargetInfo* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// -------------------------------------------------------------------

// BoxColorInfo

// optional int32 red = 1;
inline bool BoxColorInfo::has_red() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxColorInfo::set_has_red() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxColorInfo::clear_has_red() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxColorInfo::clear_red() {
  red_ = 0;
  clear_has_red();
}
inline ::google::protobuf::int32 BoxColorInfo::red() const {
  return red_;
}
inline void BoxColorInfo::set_red(::google::protobuf::int32 value) {
  set_has_red();
  red_ = value;
}

// optional int32 green = 2;
inline bool BoxColorInfo::has_green() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxColorInfo::set_has_green() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxColorInfo::clear_has_green() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxColorInfo::clear_green() {
  green_ = 0;
  clear_has_green();
}
inline ::google::protobuf::int32 BoxColorInfo::green() const {
  return green_;
}
inline void BoxColorInfo::set_green(::google::protobuf::int32 value) {
  set_has_green();
  green_ = value;
}

// optional int32 blue = 3;
inline bool BoxColorInfo::has_blue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoxColorInfo::set_has_blue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoxColorInfo::clear_has_blue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoxColorInfo::clear_blue() {
  blue_ = 0;
  clear_has_blue();
}
inline ::google::protobuf::int32 BoxColorInfo::blue() const {
  return blue_;
}
inline void BoxColorInfo::set_blue(::google::protobuf::int32 value) {
  set_has_blue();
  blue_ = value;
}

// optional int32 alpha = 4;
inline bool BoxColorInfo::has_alpha() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoxColorInfo::set_has_alpha() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoxColorInfo::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoxColorInfo::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline ::google::protobuf::int32 BoxColorInfo::alpha() const {
  return alpha_;
}
inline void BoxColorInfo::set_alpha(::google::protobuf::int32 value) {
  set_has_alpha();
  alpha_ = value;
}

// -------------------------------------------------------------------

// EffectInfo

// optional int32 interval = 1;
inline bool EffectInfo::has_interval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectInfo::set_has_interval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectInfo::clear_has_interval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectInfo::clear_interval() {
  interval_ = 0;
  clear_has_interval();
}
inline ::google::protobuf::int32 EffectInfo::interval() const {
  return interval_;
}
inline void EffectInfo::set_interval(::google::protobuf::int32 value) {
  set_has_interval();
  interval_ = value;
}

// -------------------------------------------------------------------

// LineInfo_Split

// optional .cloudbox.protobuf.ImageInfo img = 1;
inline bool LineInfo_Split::has_img() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineInfo_Split::set_has_img() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineInfo_Split::clear_has_img() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineInfo_Split::clear_img() {
  if (img_ != NULL) img_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_img();
}
inline const ::cloudbox::protobuf::ImageInfo& LineInfo_Split::img() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return img_ != NULL ? *img_ : *default_instance().img_;
#else
  return img_ != NULL ? *img_ : *default_instance_->img_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* LineInfo_Split::mutable_img() {
  set_has_img();
  if (img_ == NULL) img_ = new ::cloudbox::protobuf::ImageInfo;
  return img_;
}
inline ::cloudbox::protobuf::ImageInfo* LineInfo_Split::release_img() {
  clear_has_img();
  ::cloudbox::protobuf::ImageInfo* temp = img_;
  img_ = NULL;
  return temp;
}
inline void LineInfo_Split::set_allocated_img(::cloudbox::protobuf::ImageInfo* img) {
  delete img_;
  img_ = img;
  if (img) {
    set_has_img();
  } else {
    clear_has_img();
  }
}

// optional string name = 2;
inline bool LineInfo_Split::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineInfo_Split::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineInfo_Split::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineInfo_Split::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LineInfo_Split::name() const {
  return *name_;
}
inline void LineInfo_Split::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LineInfo_Split::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LineInfo_Split::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LineInfo_Split::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LineInfo_Split::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LineInfo_Split::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 score = 3;
inline bool LineInfo_Split::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineInfo_Split::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineInfo_Split::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineInfo_Split::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 LineInfo_Split::score() const {
  return score_;
}
inline void LineInfo_Split::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// LineInfo

// optional .cloudbox.protobuf.LineInfo.Type type = 1;
inline bool LineInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cloudbox::protobuf::LineInfo_Type LineInfo::type() const {
  return static_cast< ::cloudbox::protobuf::LineInfo_Type >(type_);
}
inline void LineInfo::set_type(::cloudbox::protobuf::LineInfo_Type value) {
  assert(::cloudbox::protobuf::LineInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string key = 2;
inline bool LineInfo::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineInfo::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineInfo::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineInfo::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& LineInfo::key() const {
  return *key_;
}
inline void LineInfo::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LineInfo::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LineInfo::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LineInfo::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* LineInfo::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LineInfo::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string values = 3;
inline int LineInfo::values_size() const {
  return values_.size();
}
inline void LineInfo::clear_values() {
  values_.Clear();
}
inline const ::std::string& LineInfo::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* LineInfo::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void LineInfo::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void LineInfo::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void LineInfo::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LineInfo::add_values() {
  return values_.Add();
}
inline void LineInfo::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void LineInfo::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void LineInfo::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LineInfo::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LineInfo::mutable_values() {
  return &values_;
}

// optional .cloudbox.protobuf.LineInfo.Split left = 4;
inline bool LineInfo::has_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineInfo::set_has_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineInfo::clear_has_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineInfo::clear_left() {
  if (left_ != NULL) left_->::cloudbox::protobuf::LineInfo_Split::Clear();
  clear_has_left();
}
inline const ::cloudbox::protobuf::LineInfo_Split& LineInfo::left() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return left_ != NULL ? *left_ : *default_instance().left_;
#else
  return left_ != NULL ? *left_ : *default_instance_->left_;
#endif
}
inline ::cloudbox::protobuf::LineInfo_Split* LineInfo::mutable_left() {
  set_has_left();
  if (left_ == NULL) left_ = new ::cloudbox::protobuf::LineInfo_Split;
  return left_;
}
inline ::cloudbox::protobuf::LineInfo_Split* LineInfo::release_left() {
  clear_has_left();
  ::cloudbox::protobuf::LineInfo_Split* temp = left_;
  left_ = NULL;
  return temp;
}
inline void LineInfo::set_allocated_left(::cloudbox::protobuf::LineInfo_Split* left) {
  delete left_;
  left_ = left;
  if (left) {
    set_has_left();
  } else {
    clear_has_left();
  }
}

// optional .cloudbox.protobuf.LineInfo.Split right = 5;
inline bool LineInfo::has_right() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LineInfo::set_has_right() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LineInfo::clear_has_right() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LineInfo::clear_right() {
  if (right_ != NULL) right_->::cloudbox::protobuf::LineInfo_Split::Clear();
  clear_has_right();
}
inline const ::cloudbox::protobuf::LineInfo_Split& LineInfo::right() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return right_ != NULL ? *right_ : *default_instance().right_;
#else
  return right_ != NULL ? *right_ : *default_instance_->right_;
#endif
}
inline ::cloudbox::protobuf::LineInfo_Split* LineInfo::mutable_right() {
  set_has_right();
  if (right_ == NULL) right_ = new ::cloudbox::protobuf::LineInfo_Split;
  return right_;
}
inline ::cloudbox::protobuf::LineInfo_Split* LineInfo::release_right() {
  clear_has_right();
  ::cloudbox::protobuf::LineInfo_Split* temp = right_;
  right_ = NULL;
  return temp;
}
inline void LineInfo::set_allocated_right(::cloudbox::protobuf::LineInfo_Split* right) {
  delete right_;
  right_ = right;
  if (right) {
    set_has_right();
  } else {
    clear_has_right();
  }
}

// -------------------------------------------------------------------

// BoxInfo

// optional float width = 1;
inline bool BoxInfo::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxInfo::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxInfo::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float BoxInfo::width() const {
  return width_;
}
inline void BoxInfo::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float height = 2;
inline bool BoxInfo::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxInfo::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxInfo::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float BoxInfo::height() const {
  return height_;
}
inline void BoxInfo::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional string url = 3;
inline bool BoxInfo::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoxInfo::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoxInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoxInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& BoxInfo::url() const {
  return *url_;
}
inline void BoxInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void BoxInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void BoxInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* BoxInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cloudbox.protobuf.ImageInfo img = 4;
inline bool BoxInfo::has_img() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoxInfo::set_has_img() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoxInfo::clear_has_img() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoxInfo::clear_img() {
  if (img_ != NULL) img_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_img();
}
inline const ::cloudbox::protobuf::ImageInfo& BoxInfo::img() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return img_ != NULL ? *img_ : *default_instance().img_;
#else
  return img_ != NULL ? *img_ : *default_instance_->img_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::mutable_img() {
  set_has_img();
  if (img_ == NULL) img_ = new ::cloudbox::protobuf::ImageInfo;
  return img_;
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::release_img() {
  clear_has_img();
  ::cloudbox::protobuf::ImageInfo* temp = img_;
  img_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_img(::cloudbox::protobuf::ImageInfo* img) {
  delete img_;
  img_ = img;
  if (img) {
    set_has_img();
  } else {
    clear_has_img();
  }
}

// optional .cloudbox.protobuf.BoxInfo.Type type = 5;
inline bool BoxInfo::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BoxInfo::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BoxInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BoxInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cloudbox::protobuf::BoxInfo_Type BoxInfo::type() const {
  return static_cast< ::cloudbox::protobuf::BoxInfo_Type >(type_);
}
inline void BoxInfo::set_type(::cloudbox::protobuf::BoxInfo_Type value) {
  assert(::cloudbox::protobuf::BoxInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 focusable = 6;
inline bool BoxInfo::has_focusable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BoxInfo::set_has_focusable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BoxInfo::clear_has_focusable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BoxInfo::clear_focusable() {
  focusable_ = 0;
  clear_has_focusable();
}
inline ::google::protobuf::int32 BoxInfo::focusable() const {
  return focusable_;
}
inline void BoxInfo::set_focusable(::google::protobuf::int32 value) {
  set_has_focusable();
  focusable_ = value;
}

// optional string channel = 7;
inline bool BoxInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BoxInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BoxInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BoxInfo::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& BoxInfo::channel() const {
  return *channel_;
}
inline void BoxInfo::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BoxInfo::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void BoxInfo::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* BoxInfo::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 8;
inline bool BoxInfo::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BoxInfo::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BoxInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BoxInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BoxInfo::id() const {
  return *id_;
}
inline void BoxInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BoxInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BoxInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* BoxInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string title = 9;
inline bool BoxInfo::has_title() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BoxInfo::set_has_title() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BoxInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BoxInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& BoxInfo::title() const {
  return *title_;
}
inline void BoxInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void BoxInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void BoxInfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* BoxInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string subTitle = 10;
inline bool BoxInfo::has_subtitle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BoxInfo::set_has_subtitle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BoxInfo::clear_has_subtitle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BoxInfo::clear_subtitle() {
  if (subtitle_ != &::google::protobuf::internal::kEmptyString) {
    subtitle_->clear();
  }
  clear_has_subtitle();
}
inline const ::std::string& BoxInfo::subtitle() const {
  return *subtitle_;
}
inline void BoxInfo::set_subtitle(const ::std::string& value) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(value);
}
inline void BoxInfo::set_subtitle(const char* value) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(value);
}
inline void BoxInfo::set_subtitle(const char* value, size_t size) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_subtitle() {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  return subtitle_;
}
inline ::std::string* BoxInfo::release_subtitle() {
  clear_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtitle_;
    subtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_subtitle(::std::string* subtitle) {
  if (subtitle_ != &::google::protobuf::internal::kEmptyString) {
    delete subtitle_;
  }
  if (subtitle) {
    set_has_subtitle();
    subtitle_ = subtitle;
  } else {
    clear_has_subtitle();
    subtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 score = 11;
inline bool BoxInfo::has_score() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BoxInfo::set_has_score() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BoxInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BoxInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 BoxInfo::score() const {
  return score_;
}
inline void BoxInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 episode = 12;
inline bool BoxInfo::has_episode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BoxInfo::set_has_episode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BoxInfo::clear_has_episode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BoxInfo::clear_episode() {
  episode_ = 0;
  clear_has_episode();
}
inline ::google::protobuf::int32 BoxInfo::episode() const {
  return episode_;
}
inline void BoxInfo::set_episode(::google::protobuf::int32 value) {
  set_has_episode();
  episode_ = value;
}

// optional int32 totalEpisode = 13;
inline bool BoxInfo::has_totalepisode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BoxInfo::set_has_totalepisode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BoxInfo::clear_has_totalepisode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BoxInfo::clear_totalepisode() {
  totalepisode_ = 0;
  clear_has_totalepisode();
}
inline ::google::protobuf::int32 BoxInfo::totalepisode() const {
  return totalepisode_;
}
inline void BoxInfo::set_totalepisode(::google::protobuf::int32 value) {
  set_has_totalepisode();
  totalepisode_ = value;
}

// optional int32 isFinished = 14;
inline bool BoxInfo::has_isfinished() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BoxInfo::set_has_isfinished() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BoxInfo::clear_has_isfinished() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BoxInfo::clear_isfinished() {
  isfinished_ = 0;
  clear_has_isfinished();
}
inline ::google::protobuf::int32 BoxInfo::isfinished() const {
  return isfinished_;
}
inline void BoxInfo::set_isfinished(::google::protobuf::int32 value) {
  set_has_isfinished();
  isfinished_ = value;
}

// optional string description = 15;
inline bool BoxInfo::has_description() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BoxInfo::set_has_description() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BoxInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BoxInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& BoxInfo::description() const {
  return *description_;
}
inline void BoxInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void BoxInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void BoxInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* BoxInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .cloudbox.protobuf.LineInfo lines = 16;
inline int BoxInfo::lines_size() const {
  return lines_.size();
}
inline void BoxInfo::clear_lines() {
  lines_.Clear();
}
inline const ::cloudbox::protobuf::LineInfo& BoxInfo::lines(int index) const {
  return lines_.Get(index);
}
inline ::cloudbox::protobuf::LineInfo* BoxInfo::mutable_lines(int index) {
  return lines_.Mutable(index);
}
inline ::cloudbox::protobuf::LineInfo* BoxInfo::add_lines() {
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::LineInfo >&
BoxInfo::lines() const {
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::LineInfo >*
BoxInfo::mutable_lines() {
  return &lines_;
}

// optional string format = 17;
inline bool BoxInfo::has_format() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BoxInfo::set_has_format() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BoxInfo::clear_has_format() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BoxInfo::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& BoxInfo::format() const {
  return *format_;
}
inline void BoxInfo::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void BoxInfo::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void BoxInfo::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* BoxInfo::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cloudbox.protobuf.ImageInfo icon = 18;
inline bool BoxInfo::has_icon() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BoxInfo::set_has_icon() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BoxInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BoxInfo::clear_icon() {
  if (icon_ != NULL) icon_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_icon();
}
inline const ::cloudbox::protobuf::ImageInfo& BoxInfo::icon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return icon_ != NULL ? *icon_ : *default_instance().icon_;
#else
  return icon_ != NULL ? *icon_ : *default_instance_->icon_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == NULL) icon_ = new ::cloudbox::protobuf::ImageInfo;
  return icon_;
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::release_icon() {
  clear_has_icon();
  ::cloudbox::protobuf::ImageInfo* temp = icon_;
  icon_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_icon(::cloudbox::protobuf::ImageInfo* icon) {
  delete icon_;
  icon_ = icon;
  if (icon) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
}

// optional int32 site = 19;
inline bool BoxInfo::has_site() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BoxInfo::set_has_site() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BoxInfo::clear_has_site() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BoxInfo::clear_site() {
  site_ = 0;
  clear_has_site();
}
inline ::google::protobuf::int32 BoxInfo::site() const {
  return site_;
}
inline void BoxInfo::set_site(::google::protobuf::int32 value) {
  set_has_site();
  site_ = value;
}

// optional .cloudbox.protobuf.TargetInfo target = 20;
inline bool BoxInfo::has_target() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BoxInfo::set_has_target() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BoxInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BoxInfo::clear_target() {
  if (target_ != NULL) target_->::cloudbox::protobuf::TargetInfo::Clear();
  clear_has_target();
}
inline const ::cloudbox::protobuf::TargetInfo& BoxInfo::target() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return target_ != NULL ? *target_ : *default_instance().target_;
#else
  return target_ != NULL ? *target_ : *default_instance_->target_;
#endif
}
inline ::cloudbox::protobuf::TargetInfo* BoxInfo::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::cloudbox::protobuf::TargetInfo;
  return target_;
}
inline ::cloudbox::protobuf::TargetInfo* BoxInfo::release_target() {
  clear_has_target();
  ::cloudbox::protobuf::TargetInfo* temp = target_;
  target_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_target(::cloudbox::protobuf::TargetInfo* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// optional int32 rank = 21;
inline bool BoxInfo::has_rank() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BoxInfo::set_has_rank() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BoxInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BoxInfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 BoxInfo::rank() const {
  return rank_;
}
inline void BoxInfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int32 length = 22;
inline bool BoxInfo::has_length() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BoxInfo::set_has_length() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BoxInfo::clear_has_length() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BoxInfo::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 BoxInfo::length() const {
  return length_;
}
inline void BoxInfo::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional int32 totalLength = 23;
inline bool BoxInfo::has_totallength() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BoxInfo::set_has_totallength() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BoxInfo::clear_has_totallength() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BoxInfo::clear_totallength() {
  totallength_ = 0;
  clear_has_totallength();
}
inline ::google::protobuf::int32 BoxInfo::totallength() const {
  return totallength_;
}
inline void BoxInfo::set_totallength(::google::protobuf::int32 value) {
  set_has_totallength();
  totallength_ = value;
}

// optional .cloudbox.protobuf.ImageInfo background = 24;
inline bool BoxInfo::has_background() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BoxInfo::set_has_background() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BoxInfo::clear_has_background() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BoxInfo::clear_background() {
  if (background_ != NULL) background_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_background();
}
inline const ::cloudbox::protobuf::ImageInfo& BoxInfo::background() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return background_ != NULL ? *background_ : *default_instance().background_;
#else
  return background_ != NULL ? *background_ : *default_instance_->background_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::mutable_background() {
  set_has_background();
  if (background_ == NULL) background_ = new ::cloudbox::protobuf::ImageInfo;
  return background_;
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::release_background() {
  clear_has_background();
  ::cloudbox::protobuf::ImageInfo* temp = background_;
  background_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_background(::cloudbox::protobuf::ImageInfo* background) {
  delete background_;
  background_ = background;
  if (background) {
    set_has_background();
  } else {
    clear_has_background();
  }
}

// optional .cloudbox.protobuf.BoxInfo.Tag tag = 25;
inline bool BoxInfo::has_tag() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BoxInfo::set_has_tag() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BoxInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BoxInfo::clear_tag() {
  tag_ = 1;
  clear_has_tag();
}
inline ::cloudbox::protobuf::BoxInfo_Tag BoxInfo::tag() const {
  return static_cast< ::cloudbox::protobuf::BoxInfo_Tag >(tag_);
}
inline void BoxInfo::set_tag(::cloudbox::protobuf::BoxInfo_Tag value) {
  assert(::cloudbox::protobuf::BoxInfo_Tag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional string siteName = 26;
inline bool BoxInfo::has_sitename() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BoxInfo::set_has_sitename() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BoxInfo::clear_has_sitename() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BoxInfo::clear_sitename() {
  if (sitename_ != &::google::protobuf::internal::kEmptyString) {
    sitename_->clear();
  }
  clear_has_sitename();
}
inline const ::std::string& BoxInfo::sitename() const {
  return *sitename_;
}
inline void BoxInfo::set_sitename(const ::std::string& value) {
  set_has_sitename();
  if (sitename_ == &::google::protobuf::internal::kEmptyString) {
    sitename_ = new ::std::string;
  }
  sitename_->assign(value);
}
inline void BoxInfo::set_sitename(const char* value) {
  set_has_sitename();
  if (sitename_ == &::google::protobuf::internal::kEmptyString) {
    sitename_ = new ::std::string;
  }
  sitename_->assign(value);
}
inline void BoxInfo::set_sitename(const char* value, size_t size) {
  set_has_sitename();
  if (sitename_ == &::google::protobuf::internal::kEmptyString) {
    sitename_ = new ::std::string;
  }
  sitename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_sitename() {
  set_has_sitename();
  if (sitename_ == &::google::protobuf::internal::kEmptyString) {
    sitename_ = new ::std::string;
  }
  return sitename_;
}
inline ::std::string* BoxInfo::release_sitename() {
  clear_has_sitename();
  if (sitename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sitename_;
    sitename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_sitename(::std::string* sitename) {
  if (sitename_ != &::google::protobuf::internal::kEmptyString) {
    delete sitename_;
  }
  if (sitename) {
    set_has_sitename();
    sitename_ = sitename;
  } else {
    clear_has_sitename();
    sitename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 updated = 27;
inline bool BoxInfo::has_updated() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BoxInfo::set_has_updated() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BoxInfo::clear_has_updated() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BoxInfo::clear_updated() {
  updated_ = 0;
  clear_has_updated();
}
inline ::google::protobuf::int32 BoxInfo::updated() const {
  return updated_;
}
inline void BoxInfo::set_updated(::google::protobuf::int32 value) {
  set_has_updated();
  updated_ = value;
}

// optional bytes appIcon = 28;
inline bool BoxInfo::has_appicon() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BoxInfo::set_has_appicon() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BoxInfo::clear_has_appicon() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BoxInfo::clear_appicon() {
  if (appicon_ != &::google::protobuf::internal::kEmptyString) {
    appicon_->clear();
  }
  clear_has_appicon();
}
inline const ::std::string& BoxInfo::appicon() const {
  return *appicon_;
}
inline void BoxInfo::set_appicon(const ::std::string& value) {
  set_has_appicon();
  if (appicon_ == &::google::protobuf::internal::kEmptyString) {
    appicon_ = new ::std::string;
  }
  appicon_->assign(value);
}
inline void BoxInfo::set_appicon(const char* value) {
  set_has_appicon();
  if (appicon_ == &::google::protobuf::internal::kEmptyString) {
    appicon_ = new ::std::string;
  }
  appicon_->assign(value);
}
inline void BoxInfo::set_appicon(const void* value, size_t size) {
  set_has_appicon();
  if (appicon_ == &::google::protobuf::internal::kEmptyString) {
    appicon_ = new ::std::string;
  }
  appicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_appicon() {
  set_has_appicon();
  if (appicon_ == &::google::protobuf::internal::kEmptyString) {
    appicon_ = new ::std::string;
  }
  return appicon_;
}
inline ::std::string* BoxInfo::release_appicon() {
  clear_has_appicon();
  if (appicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appicon_;
    appicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_appicon(::std::string* appicon) {
  if (appicon_ != &::google::protobuf::internal::kEmptyString) {
    delete appicon_;
  }
  if (appicon) {
    set_has_appicon();
    appicon_ = appicon;
  } else {
    clear_has_appicon();
    appicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string stage = 29;
inline bool BoxInfo::has_stage() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BoxInfo::set_has_stage() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BoxInfo::clear_has_stage() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BoxInfo::clear_stage() {
  if (stage_ != &::google::protobuf::internal::kEmptyString) {
    stage_->clear();
  }
  clear_has_stage();
}
inline const ::std::string& BoxInfo::stage() const {
  return *stage_;
}
inline void BoxInfo::set_stage(const ::std::string& value) {
  set_has_stage();
  if (stage_ == &::google::protobuf::internal::kEmptyString) {
    stage_ = new ::std::string;
  }
  stage_->assign(value);
}
inline void BoxInfo::set_stage(const char* value) {
  set_has_stage();
  if (stage_ == &::google::protobuf::internal::kEmptyString) {
    stage_ = new ::std::string;
  }
  stage_->assign(value);
}
inline void BoxInfo::set_stage(const char* value, size_t size) {
  set_has_stage();
  if (stage_ == &::google::protobuf::internal::kEmptyString) {
    stage_ = new ::std::string;
  }
  stage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_stage() {
  set_has_stage();
  if (stage_ == &::google::protobuf::internal::kEmptyString) {
    stage_ = new ::std::string;
  }
  return stage_;
}
inline ::std::string* BoxInfo::release_stage() {
  clear_has_stage();
  if (stage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stage_;
    stage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_stage(::std::string* stage) {
  if (stage_ != &::google::protobuf::internal::kEmptyString) {
    delete stage_;
  }
  if (stage) {
    set_has_stage();
    stage_ = stage;
  } else {
    clear_has_stage();
    stage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 playNum = 30;
inline bool BoxInfo::has_playnum() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BoxInfo::set_has_playnum() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BoxInfo::clear_has_playnum() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BoxInfo::clear_playnum() {
  playnum_ = 0;
  clear_has_playnum();
}
inline ::google::protobuf::int32 BoxInfo::playnum() const {
  return playnum_;
}
inline void BoxInfo::set_playnum(::google::protobuf::int32 value) {
  set_has_playnum();
  playnum_ = value;
}

// optional string playNumTitle = 31;
inline bool BoxInfo::has_playnumtitle() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BoxInfo::set_has_playnumtitle() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BoxInfo::clear_has_playnumtitle() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BoxInfo::clear_playnumtitle() {
  if (playnumtitle_ != &::google::protobuf::internal::kEmptyString) {
    playnumtitle_->clear();
  }
  clear_has_playnumtitle();
}
inline const ::std::string& BoxInfo::playnumtitle() const {
  return *playnumtitle_;
}
inline void BoxInfo::set_playnumtitle(const ::std::string& value) {
  set_has_playnumtitle();
  if (playnumtitle_ == &::google::protobuf::internal::kEmptyString) {
    playnumtitle_ = new ::std::string;
  }
  playnumtitle_->assign(value);
}
inline void BoxInfo::set_playnumtitle(const char* value) {
  set_has_playnumtitle();
  if (playnumtitle_ == &::google::protobuf::internal::kEmptyString) {
    playnumtitle_ = new ::std::string;
  }
  playnumtitle_->assign(value);
}
inline void BoxInfo::set_playnumtitle(const char* value, size_t size) {
  set_has_playnumtitle();
  if (playnumtitle_ == &::google::protobuf::internal::kEmptyString) {
    playnumtitle_ = new ::std::string;
  }
  playnumtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxInfo::mutable_playnumtitle() {
  set_has_playnumtitle();
  if (playnumtitle_ == &::google::protobuf::internal::kEmptyString) {
    playnumtitle_ = new ::std::string;
  }
  return playnumtitle_;
}
inline ::std::string* BoxInfo::release_playnumtitle() {
  clear_has_playnumtitle();
  if (playnumtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playnumtitle_;
    playnumtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxInfo::set_allocated_playnumtitle(::std::string* playnumtitle) {
  if (playnumtitle_ != &::google::protobuf::internal::kEmptyString) {
    delete playnumtitle_;
  }
  if (playnumtitle) {
    set_has_playnumtitle();
    playnumtitle_ = playnumtitle;
  } else {
    clear_has_playnumtitle();
    playnumtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cloudbox.protobuf.ImageInfo mImg = 32;
inline bool BoxInfo::has_mimg() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BoxInfo::set_has_mimg() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BoxInfo::clear_has_mimg() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BoxInfo::clear_mimg() {
  if (mimg_ != NULL) mimg_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_mimg();
}
inline const ::cloudbox::protobuf::ImageInfo& BoxInfo::mimg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mimg_ != NULL ? *mimg_ : *default_instance().mimg_;
#else
  return mimg_ != NULL ? *mimg_ : *default_instance_->mimg_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::mutable_mimg() {
  set_has_mimg();
  if (mimg_ == NULL) mimg_ = new ::cloudbox::protobuf::ImageInfo;
  return mimg_;
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::release_mimg() {
  clear_has_mimg();
  ::cloudbox::protobuf::ImageInfo* temp = mimg_;
  mimg_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_mimg(::cloudbox::protobuf::ImageInfo* mimg) {
  delete mimg_;
  mimg_ = mimg;
  if (mimg) {
    set_has_mimg();
  } else {
    clear_has_mimg();
  }
}

// optional int32 ts = 33;
inline bool BoxInfo::has_ts() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BoxInfo::set_has_ts() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BoxInfo::clear_has_ts() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BoxInfo::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline ::google::protobuf::int32 BoxInfo::ts() const {
  return ts_;
}
inline void BoxInfo::set_ts(::google::protobuf::int32 value) {
  set_has_ts();
  ts_ = value;
}

// optional .cloudbox.protobuf.ImageInfo fixedImg = 34;
inline bool BoxInfo::has_fixedimg() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BoxInfo::set_has_fixedimg() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BoxInfo::clear_has_fixedimg() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BoxInfo::clear_fixedimg() {
  if (fixedimg_ != NULL) fixedimg_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_fixedimg();
}
inline const ::cloudbox::protobuf::ImageInfo& BoxInfo::fixedimg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fixedimg_ != NULL ? *fixedimg_ : *default_instance().fixedimg_;
#else
  return fixedimg_ != NULL ? *fixedimg_ : *default_instance_->fixedimg_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::mutable_fixedimg() {
  set_has_fixedimg();
  if (fixedimg_ == NULL) fixedimg_ = new ::cloudbox::protobuf::ImageInfo;
  return fixedimg_;
}
inline ::cloudbox::protobuf::ImageInfo* BoxInfo::release_fixedimg() {
  clear_has_fixedimg();
  ::cloudbox::protobuf::ImageInfo* temp = fixedimg_;
  fixedimg_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_fixedimg(::cloudbox::protobuf::ImageInfo* fixedimg) {
  delete fixedimg_;
  fixedimg_ = fixedimg;
  if (fixedimg) {
    set_has_fixedimg();
  } else {
    clear_has_fixedimg();
  }
}

// optional int32 showTitle = 35;
inline bool BoxInfo::has_showtitle() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BoxInfo::set_has_showtitle() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BoxInfo::clear_has_showtitle() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BoxInfo::clear_showtitle() {
  showtitle_ = 0;
  clear_has_showtitle();
}
inline ::google::protobuf::int32 BoxInfo::showtitle() const {
  return showtitle_;
}
inline void BoxInfo::set_showtitle(::google::protobuf::int32 value) {
  set_has_showtitle();
  showtitle_ = value;
}

// repeated .cloudbox.protobuf.IconInfo icons = 36;
inline int BoxInfo::icons_size() const {
  return icons_.size();
}
inline void BoxInfo::clear_icons() {
  icons_.Clear();
}
inline const ::cloudbox::protobuf::IconInfo& BoxInfo::icons(int index) const {
  return icons_.Get(index);
}
inline ::cloudbox::protobuf::IconInfo* BoxInfo::mutable_icons(int index) {
  return icons_.Mutable(index);
}
inline ::cloudbox::protobuf::IconInfo* BoxInfo::add_icons() {
  return icons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::IconInfo >&
BoxInfo::icons() const {
  return icons_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::IconInfo >*
BoxInfo::mutable_icons() {
  return &icons_;
}

// optional int32 effectType = 37;
inline bool BoxInfo::has_effecttype() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BoxInfo::set_has_effecttype() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BoxInfo::clear_has_effecttype() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BoxInfo::clear_effecttype() {
  effecttype_ = 0;
  clear_has_effecttype();
}
inline ::google::protobuf::int32 BoxInfo::effecttype() const {
  return effecttype_;
}
inline void BoxInfo::set_effecttype(::google::protobuf::int32 value) {
  set_has_effecttype();
  effecttype_ = value;
}

// optional .cloudbox.protobuf.EffectInfo effectInfo = 38;
inline bool BoxInfo::has_effectinfo() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void BoxInfo::set_has_effectinfo() {
  _has_bits_[1] |= 0x00000020u;
}
inline void BoxInfo::clear_has_effectinfo() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void BoxInfo::clear_effectinfo() {
  if (effectinfo_ != NULL) effectinfo_->::cloudbox::protobuf::EffectInfo::Clear();
  clear_has_effectinfo();
}
inline const ::cloudbox::protobuf::EffectInfo& BoxInfo::effectinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return effectinfo_ != NULL ? *effectinfo_ : *default_instance().effectinfo_;
#else
  return effectinfo_ != NULL ? *effectinfo_ : *default_instance_->effectinfo_;
#endif
}
inline ::cloudbox::protobuf::EffectInfo* BoxInfo::mutable_effectinfo() {
  set_has_effectinfo();
  if (effectinfo_ == NULL) effectinfo_ = new ::cloudbox::protobuf::EffectInfo;
  return effectinfo_;
}
inline ::cloudbox::protobuf::EffectInfo* BoxInfo::release_effectinfo() {
  clear_has_effectinfo();
  ::cloudbox::protobuf::EffectInfo* temp = effectinfo_;
  effectinfo_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_effectinfo(::cloudbox::protobuf::EffectInfo* effectinfo) {
  delete effectinfo_;
  effectinfo_ = effectinfo;
  if (effectinfo) {
    set_has_effectinfo();
  } else {
    clear_has_effectinfo();
  }
}

// optional int32 spacing = 39;
inline bool BoxInfo::has_spacing() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void BoxInfo::set_has_spacing() {
  _has_bits_[1] |= 0x00000040u;
}
inline void BoxInfo::clear_has_spacing() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void BoxInfo::clear_spacing() {
  spacing_ = 0;
  clear_has_spacing();
}
inline ::google::protobuf::int32 BoxInfo::spacing() const {
  return spacing_;
}
inline void BoxInfo::set_spacing(::google::protobuf::int32 value) {
  set_has_spacing();
  spacing_ = value;
}

// optional .cloudbox.protobuf.BoxColorInfo boxColor = 40;
inline bool BoxInfo::has_boxcolor() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void BoxInfo::set_has_boxcolor() {
  _has_bits_[1] |= 0x00000080u;
}
inline void BoxInfo::clear_has_boxcolor() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void BoxInfo::clear_boxcolor() {
  if (boxcolor_ != NULL) boxcolor_->::cloudbox::protobuf::BoxColorInfo::Clear();
  clear_has_boxcolor();
}
inline const ::cloudbox::protobuf::BoxColorInfo& BoxInfo::boxcolor() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return boxcolor_ != NULL ? *boxcolor_ : *default_instance().boxcolor_;
#else
  return boxcolor_ != NULL ? *boxcolor_ : *default_instance_->boxcolor_;
#endif
}
inline ::cloudbox::protobuf::BoxColorInfo* BoxInfo::mutable_boxcolor() {
  set_has_boxcolor();
  if (boxcolor_ == NULL) boxcolor_ = new ::cloudbox::protobuf::BoxColorInfo;
  return boxcolor_;
}
inline ::cloudbox::protobuf::BoxColorInfo* BoxInfo::release_boxcolor() {
  clear_has_boxcolor();
  ::cloudbox::protobuf::BoxColorInfo* temp = boxcolor_;
  boxcolor_ = NULL;
  return temp;
}
inline void BoxInfo::set_allocated_boxcolor(::cloudbox::protobuf::BoxColorInfo* boxcolor) {
  delete boxcolor_;
  boxcolor_ = boxcolor;
  if (boxcolor) {
    set_has_boxcolor();
  } else {
    clear_has_boxcolor();
  }
}

// -------------------------------------------------------------------

// PlayUrlInfo

// optional string format = 1;
inline bool PlayUrlInfo::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayUrlInfo::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayUrlInfo::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayUrlInfo::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& PlayUrlInfo::format() const {
  return *format_;
}
inline void PlayUrlInfo::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void PlayUrlInfo::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void PlayUrlInfo::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayUrlInfo::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* PlayUrlInfo::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayUrlInfo::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 2;
inline bool PlayUrlInfo::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayUrlInfo::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayUrlInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayUrlInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& PlayUrlInfo::url() const {
  return *url_;
}
inline void PlayUrlInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void PlayUrlInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void PlayUrlInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayUrlInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* PlayUrlInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayUrlInfo::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float op = 3;
inline bool PlayUrlInfo::has_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayUrlInfo::set_has_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayUrlInfo::clear_has_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayUrlInfo::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline float PlayUrlInfo::op() const {
  return op_;
}
inline void PlayUrlInfo::set_op(float value) {
  set_has_op();
  op_ = value;
}

// optional float ed = 4;
inline bool PlayUrlInfo::has_ed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayUrlInfo::set_has_ed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayUrlInfo::clear_has_ed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayUrlInfo::clear_ed() {
  ed_ = 0;
  clear_has_ed();
}
inline float PlayUrlInfo::ed() const {
  return ed_;
}
inline void PlayUrlInfo::set_ed(float value) {
  set_has_ed();
  ed_ = value;
}

// optional int32 urltype = 5;
inline bool PlayUrlInfo::has_urltype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayUrlInfo::set_has_urltype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayUrlInfo::clear_has_urltype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayUrlInfo::clear_urltype() {
  urltype_ = 0;
  clear_has_urltype();
}
inline ::google::protobuf::int32 PlayUrlInfo::urltype() const {
  return urltype_;
}
inline void PlayUrlInfo::set_urltype(::google::protobuf::int32 value) {
  set_has_urltype();
  urltype_ = value;
}

// -------------------------------------------------------------------

// PlaySiteInfo

// optional int32 site = 1;
inline bool PlaySiteInfo::has_site() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaySiteInfo::set_has_site() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaySiteInfo::clear_has_site() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaySiteInfo::clear_site() {
  site_ = 0;
  clear_has_site();
}
inline ::google::protobuf::int32 PlaySiteInfo::site() const {
  return site_;
}
inline void PlaySiteInfo::set_site(::google::protobuf::int32 value) {
  set_has_site();
  site_ = value;
}

// optional string name = 2;
inline bool PlaySiteInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlaySiteInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlaySiteInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlaySiteInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlaySiteInfo::name() const {
  return *name_;
}
inline void PlaySiteInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlaySiteInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlaySiteInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaySiteInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlaySiteInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlaySiteInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 3;
inline bool PlaySiteInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlaySiteInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlaySiteInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlaySiteInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PlaySiteInfo::id() const {
  return *id_;
}
inline void PlaySiteInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PlaySiteInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PlaySiteInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaySiteInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PlaySiteInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlaySiteInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 length = 4;
inline bool PlaySiteInfo::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlaySiteInfo::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlaySiteInfo::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlaySiteInfo::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 PlaySiteInfo::length() const {
  return length_;
}
inline void PlaySiteInfo::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// repeated .cloudbox.protobuf.PlayUrlInfo urls = 5;
inline int PlaySiteInfo::urls_size() const {
  return urls_.size();
}
inline void PlaySiteInfo::clear_urls() {
  urls_.Clear();
}
inline const ::cloudbox::protobuf::PlayUrlInfo& PlaySiteInfo::urls(int index) const {
  return urls_.Get(index);
}
inline ::cloudbox::protobuf::PlayUrlInfo* PlaySiteInfo::mutable_urls(int index) {
  return urls_.Mutable(index);
}
inline ::cloudbox::protobuf::PlayUrlInfo* PlaySiteInfo::add_urls() {
  return urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlayUrlInfo >&
PlaySiteInfo::urls() const {
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlayUrlInfo >*
PlaySiteInfo::mutable_urls() {
  return &urls_;
}

// optional string title = 6;
inline bool PlaySiteInfo::has_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlaySiteInfo::set_has_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlaySiteInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlaySiteInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& PlaySiteInfo::title() const {
  return *title_;
}
inline void PlaySiteInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void PlaySiteInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void PlaySiteInfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaySiteInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* PlaySiteInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlaySiteInfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cloudbox.protobuf.ImageInfo logo = 7;
inline bool PlaySiteInfo::has_logo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlaySiteInfo::set_has_logo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlaySiteInfo::clear_has_logo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlaySiteInfo::clear_logo() {
  if (logo_ != NULL) logo_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_logo();
}
inline const ::cloudbox::protobuf::ImageInfo& PlaySiteInfo::logo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return logo_ != NULL ? *logo_ : *default_instance().logo_;
#else
  return logo_ != NULL ? *logo_ : *default_instance_->logo_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* PlaySiteInfo::mutable_logo() {
  set_has_logo();
  if (logo_ == NULL) logo_ = new ::cloudbox::protobuf::ImageInfo;
  return logo_;
}
inline ::cloudbox::protobuf::ImageInfo* PlaySiteInfo::release_logo() {
  clear_has_logo();
  ::cloudbox::protobuf::ImageInfo* temp = logo_;
  logo_ = NULL;
  return temp;
}
inline void PlaySiteInfo::set_allocated_logo(::cloudbox::protobuf::ImageInfo* logo) {
  delete logo_;
  logo_ = logo;
  if (logo) {
    set_has_logo();
  } else {
    clear_has_logo();
  }
}

// optional string luaInfo = 8;
inline bool PlaySiteInfo::has_luainfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlaySiteInfo::set_has_luainfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlaySiteInfo::clear_has_luainfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlaySiteInfo::clear_luainfo() {
  if (luainfo_ != &::google::protobuf::internal::kEmptyString) {
    luainfo_->clear();
  }
  clear_has_luainfo();
}
inline const ::std::string& PlaySiteInfo::luainfo() const {
  return *luainfo_;
}
inline void PlaySiteInfo::set_luainfo(const ::std::string& value) {
  set_has_luainfo();
  if (luainfo_ == &::google::protobuf::internal::kEmptyString) {
    luainfo_ = new ::std::string;
  }
  luainfo_->assign(value);
}
inline void PlaySiteInfo::set_luainfo(const char* value) {
  set_has_luainfo();
  if (luainfo_ == &::google::protobuf::internal::kEmptyString) {
    luainfo_ = new ::std::string;
  }
  luainfo_->assign(value);
}
inline void PlaySiteInfo::set_luainfo(const char* value, size_t size) {
  set_has_luainfo();
  if (luainfo_ == &::google::protobuf::internal::kEmptyString) {
    luainfo_ = new ::std::string;
  }
  luainfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaySiteInfo::mutable_luainfo() {
  set_has_luainfo();
  if (luainfo_ == &::google::protobuf::internal::kEmptyString) {
    luainfo_ = new ::std::string;
  }
  return luainfo_;
}
inline ::std::string* PlaySiteInfo::release_luainfo() {
  clear_has_luainfo();
  if (luainfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = luainfo_;
    luainfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlaySiteInfo::set_allocated_luainfo(::std::string* luainfo) {
  if (luainfo_ != &::google::protobuf::internal::kEmptyString) {
    delete luainfo_;
  }
  if (luainfo) {
    set_has_luainfo();
    luainfo_ = luainfo;
  } else {
    clear_has_luainfo();
    luainfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace cloudbox

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
