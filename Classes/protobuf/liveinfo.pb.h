// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: liveinfo.proto

#ifndef PROTOBUF_liveinfo_2eproto__INCLUDED
#define PROTOBUF_liveinfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace cloudbox {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_liveinfo_2eproto();
void protobuf_AssignDesc_liveinfo_2eproto();
void protobuf_ShutdownFile_liveinfo_2eproto();

class ProgramInfo;
class StationInfo;
class TagInfo;
class ProgramListInfo;
class StationListInfo;
class TagListInfo;
class StationTagInfo;
class StationTagList;
class LiveInfo;

// ===================================================================

class ProgramInfo : public ::google::protobuf::MessageLite {
 public:
  ProgramInfo();
  virtual ~ProgramInfo();

  ProgramInfo(const ProgramInfo& from);

  inline ProgramInfo& operator=(const ProgramInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ProgramInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProgramInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProgramInfo* other);

  // implements Message ----------------------------------------------

  ProgramInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProgramInfo& from);
  void MergeFrom(const ProgramInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string station = 2;
  inline bool has_station() const;
  inline void clear_station();
  static const int kStationFieldNumber = 2;
  inline const ::std::string& station() const;
  inline void set_station(const ::std::string& value);
  inline void set_station(const char* value);
  inline void set_station(const char* value, size_t size);
  inline ::std::string* mutable_station();
  inline ::std::string* release_station();
  inline void set_allocated_station(::std::string* station);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline const ::std::string& start() const;
  inline void set_start(const ::std::string& value);
  inline void set_start(const char* value);
  inline void set_start(const char* value, size_t size);
  inline ::std::string* mutable_start();
  inline ::std::string* release_start();
  inline void set_allocated_start(::std::string* start);

  // optional string end = 5;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 5;
  inline const ::std::string& end() const;
  inline void set_end(const ::std::string& value);
  inline void set_end(const char* value);
  inline void set_end(const char* value, size_t size);
  inline ::std::string* mutable_end();
  inline ::std::string* release_end();
  inline void set_allocated_end(::std::string* end);

  // optional int32 startTimestamp = 6;
  inline bool has_starttimestamp() const;
  inline void clear_starttimestamp();
  static const int kStartTimestampFieldNumber = 6;
  inline ::google::protobuf::int32 starttimestamp() const;
  inline void set_starttimestamp(::google::protobuf::int32 value);

  // optional int32 endTimestamp = 7;
  inline bool has_endtimestamp() const;
  inline void clear_endtimestamp();
  static const int kEndTimestampFieldNumber = 7;
  inline ::google::protobuf::int32 endtimestamp() const;
  inline void set_endtimestamp(::google::protobuf::int32 value);

  // optional int32 isHot = 8;
  inline bool has_ishot() const;
  inline void clear_ishot();
  static const int kIsHotFieldNumber = 8;
  inline ::google::protobuf::int32 ishot() const;
  inline void set_ishot(::google::protobuf::int32 value);

  // optional .cloudbox.protobuf.ImageInfo img = 9;
  inline bool has_img() const;
  inline void clear_img();
  static const int kImgFieldNumber = 9;
  inline const ::cloudbox::protobuf::ImageInfo& img() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_img();
  inline ::cloudbox::protobuf::ImageInfo* release_img();
  inline void set_allocated_img(::cloudbox::protobuf::ImageInfo* img);

  // optional int32 code = 10;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 10;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string stationName = 11;
  inline bool has_stationname() const;
  inline void clear_stationname();
  static const int kStationNameFieldNumber = 11;
  inline const ::std::string& stationname() const;
  inline void set_stationname(const ::std::string& value);
  inline void set_stationname(const char* value);
  inline void set_stationname(const char* value, size_t size);
  inline ::std::string* mutable_stationname();
  inline ::std::string* release_stationname();
  inline void set_allocated_stationname(::std::string* stationname);

  // optional .cloudbox.protobuf.ImageInfo icon = 12;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 12;
  inline const ::cloudbox::protobuf::ImageInfo& icon() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_icon();
  inline ::cloudbox::protobuf::ImageInfo* release_icon();
  inline void set_allocated_icon(::cloudbox::protobuf::ImageInfo* icon);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.ProgramInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_station();
  inline void clear_has_station();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_starttimestamp();
  inline void clear_has_starttimestamp();
  inline void set_has_endtimestamp();
  inline void clear_has_endtimestamp();
  inline void set_has_ishot();
  inline void clear_has_ishot();
  inline void set_has_img();
  inline void clear_has_img();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_stationname();
  inline void clear_has_stationname();
  inline void set_has_icon();
  inline void clear_has_icon();

  ::std::string* id_;
  ::std::string* station_;
  ::std::string* name_;
  ::std::string* start_;
  ::std::string* end_;
  ::google::protobuf::int32 starttimestamp_;
  ::google::protobuf::int32 endtimestamp_;
  ::cloudbox::protobuf::ImageInfo* img_;
  ::google::protobuf::int32 ishot_;
  ::google::protobuf::int32 code_;
  ::std::string* stationname_;
  ::cloudbox::protobuf::ImageInfo* icon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static ProgramInfo* default_instance_;
};
// -------------------------------------------------------------------

class StationInfo : public ::google::protobuf::MessageLite {
 public:
  StationInfo();
  virtual ~StationInfo();

  StationInfo(const StationInfo& from);

  inline StationInfo& operator=(const StationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const StationInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StationInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StationInfo* other);

  // implements Message ----------------------------------------------

  StationInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StationInfo& from);
  void MergeFrom(const StationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .cloudbox.protobuf.PlaySiteInfo sites = 4;
  inline int sites_size() const;
  inline void clear_sites();
  static const int kSitesFieldNumber = 4;
  inline const ::cloudbox::protobuf::PlaySiteInfo& sites(int index) const;
  inline ::cloudbox::protobuf::PlaySiteInfo* mutable_sites(int index);
  inline ::cloudbox::protobuf::PlaySiteInfo* add_sites();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlaySiteInfo >&
      sites() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlaySiteInfo >*
      mutable_sites();

  // optional .cloudbox.protobuf.ImageInfo icon = 5;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 5;
  inline const ::cloudbox::protobuf::ImageInfo& icon() const;
  inline ::cloudbox::protobuf::ImageInfo* mutable_icon();
  inline ::cloudbox::protobuf::ImageInfo* release_icon();
  inline void set_allocated_icon(::cloudbox::protobuf::ImageInfo* icon);

  // repeated int32 tags = 6;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 6;
  inline ::google::protobuf::int32 tags(int index) const;
  inline void set_tags(int index, ::google::protobuf::int32 value);
  inline void add_tags(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tags() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tags();

  // repeated .cloudbox.protobuf.ProgramInfo programs = 7;
  inline int programs_size() const;
  inline void clear_programs();
  static const int kProgramsFieldNumber = 7;
  inline const ::cloudbox::protobuf::ProgramInfo& programs(int index) const;
  inline ::cloudbox::protobuf::ProgramInfo* mutable_programs(int index);
  inline ::cloudbox::protobuf::ProgramInfo* add_programs();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >&
      programs() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >*
      mutable_programs();

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.StationInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_icon();
  inline void clear_has_icon();

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlaySiteInfo > sites_;
  ::cloudbox::protobuf::ImageInfo* icon_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tags_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo > programs_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static StationInfo* default_instance_;
};
// -------------------------------------------------------------------

class TagInfo : public ::google::protobuf::MessageLite {
 public:
  TagInfo();
  virtual ~TagInfo();

  TagInfo(const TagInfo& from);

  inline TagInfo& operator=(const TagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TagInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TagInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TagInfo* other);

  // implements Message ----------------------------------------------

  TagInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TagInfo& from);
  void MergeFrom(const TagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.TagInfo)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static TagInfo* default_instance_;
};
// -------------------------------------------------------------------

class ProgramListInfo : public ::google::protobuf::MessageLite {
 public:
  ProgramListInfo();
  virtual ~ProgramListInfo();

  ProgramListInfo(const ProgramListInfo& from);

  inline ProgramListInfo& operator=(const ProgramListInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ProgramListInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProgramListInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProgramListInfo* other);

  // implements Message ----------------------------------------------

  ProgramListInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProgramListInfo& from);
  void MergeFrom(const ProgramListInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.ProgramInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::cloudbox::protobuf::ProgramInfo& result(int index) const;
  inline ::cloudbox::protobuf::ProgramInfo* mutable_result(int index);
  inline ::cloudbox::protobuf::ProgramInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.ProgramListInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo > result_;
  ::google::protobuf::int32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static ProgramListInfo* default_instance_;
};
// -------------------------------------------------------------------

class StationListInfo : public ::google::protobuf::MessageLite {
 public:
  StationListInfo();
  virtual ~StationListInfo();

  StationListInfo(const StationListInfo& from);

  inline StationListInfo& operator=(const StationListInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const StationListInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StationListInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StationListInfo* other);

  // implements Message ----------------------------------------------

  StationListInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StationListInfo& from);
  void MergeFrom(const StationListInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.StationInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::cloudbox::protobuf::StationInfo& result(int index) const;
  inline ::cloudbox::protobuf::StationInfo* mutable_result(int index);
  inline ::cloudbox::protobuf::StationInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.StationListInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo > result_;
  ::google::protobuf::int32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static StationListInfo* default_instance_;
};
// -------------------------------------------------------------------

class TagListInfo : public ::google::protobuf::MessageLite {
 public:
  TagListInfo();
  virtual ~TagListInfo();

  TagListInfo(const TagListInfo& from);

  inline TagListInfo& operator=(const TagListInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TagListInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TagListInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TagListInfo* other);

  // implements Message ----------------------------------------------

  TagListInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TagListInfo& from);
  void MergeFrom(const TagListInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.TagInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::cloudbox::protobuf::TagInfo& result(int index) const;
  inline ::cloudbox::protobuf::TagInfo* mutable_result(int index);
  inline ::cloudbox::protobuf::TagInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::TagInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::TagInfo >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.TagListInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::TagInfo > result_;
  ::google::protobuf::int32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static TagListInfo* default_instance_;
};
// -------------------------------------------------------------------

class StationTagInfo : public ::google::protobuf::MessageLite {
 public:
  StationTagInfo();
  virtual ~StationTagInfo();

  StationTagInfo(const StationTagInfo& from);

  inline StationTagInfo& operator=(const StationTagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const StationTagInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StationTagInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StationTagInfo* other);

  // implements Message ----------------------------------------------

  StationTagInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StationTagInfo& from);
  void MergeFrom(const StationTagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cloudbox.protobuf.TagInfo tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::cloudbox::protobuf::TagInfo& tag() const;
  inline ::cloudbox::protobuf::TagInfo* mutable_tag();
  inline ::cloudbox::protobuf::TagInfo* release_tag();
  inline void set_allocated_tag(::cloudbox::protobuf::TagInfo* tag);

  // repeated .cloudbox.protobuf.StationInfo stations = 2;
  inline int stations_size() const;
  inline void clear_stations();
  static const int kStationsFieldNumber = 2;
  inline const ::cloudbox::protobuf::StationInfo& stations(int index) const;
  inline ::cloudbox::protobuf::StationInfo* mutable_stations(int index);
  inline ::cloudbox::protobuf::StationInfo* add_stations();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >&
      stations() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >*
      mutable_stations();

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.StationTagInfo)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();

  ::cloudbox::protobuf::TagInfo* tag_;
  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo > stations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static StationTagInfo* default_instance_;
};
// -------------------------------------------------------------------

class StationTagList : public ::google::protobuf::MessageLite {
 public:
  StationTagList();
  virtual ~StationTagList();

  StationTagList(const StationTagList& from);

  inline StationTagList& operator=(const StationTagList& from) {
    CopyFrom(from);
    return *this;
  }

  static const StationTagList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StationTagList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StationTagList* other);

  // implements Message ----------------------------------------------

  StationTagList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StationTagList& from);
  void MergeFrom(const StationTagList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated .cloudbox.protobuf.StationTagInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::cloudbox::protobuf::StationTagInfo& result(int index) const;
  inline ::cloudbox::protobuf::StationTagInfo* mutable_result(int index);
  inline ::cloudbox::protobuf::StationTagInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationTagInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationTagInfo >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.StationTagList)
 private:
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationTagInfo > result_;
  ::google::protobuf::int32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static StationTagList* default_instance_;
};
// -------------------------------------------------------------------

class LiveInfo : public ::google::protobuf::MessageLite {
 public:
  LiveInfo();
  virtual ~LiveInfo();

  LiveInfo(const LiveInfo& from);

  inline LiveInfo& operator=(const LiveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LiveInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LiveInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LiveInfo* other);

  // implements Message ----------------------------------------------

  LiveInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LiveInfo& from);
  void MergeFrom(const LiveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cloudbox.protobuf.ProgramListInfo hotPrograms = 1;
  inline bool has_hotprograms() const;
  inline void clear_hotprograms();
  static const int kHotProgramsFieldNumber = 1;
  inline const ::cloudbox::protobuf::ProgramListInfo& hotprograms() const;
  inline ::cloudbox::protobuf::ProgramListInfo* mutable_hotprograms();
  inline ::cloudbox::protobuf::ProgramListInfo* release_hotprograms();
  inline void set_allocated_hotprograms(::cloudbox::protobuf::ProgramListInfo* hotprograms);

  // optional .cloudbox.protobuf.StationListInfo stations = 2;
  inline bool has_stations() const;
  inline void clear_stations();
  static const int kStationsFieldNumber = 2;
  inline const ::cloudbox::protobuf::StationListInfo& stations() const;
  inline ::cloudbox::protobuf::StationListInfo* mutable_stations();
  inline ::cloudbox::protobuf::StationListInfo* release_stations();
  inline void set_allocated_stations(::cloudbox::protobuf::StationListInfo* stations);

  // optional .cloudbox.protobuf.TagListInfo tags = 3;
  inline bool has_tags() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 3;
  inline const ::cloudbox::protobuf::TagListInfo& tags() const;
  inline ::cloudbox::protobuf::TagListInfo* mutable_tags();
  inline ::cloudbox::protobuf::TagListInfo* release_tags();
  inline void set_allocated_tags(::cloudbox::protobuf::TagListInfo* tags);

  // @@protoc_insertion_point(class_scope:cloudbox.protobuf.LiveInfo)
 private:
  inline void set_has_hotprograms();
  inline void clear_has_hotprograms();
  inline void set_has_stations();
  inline void clear_has_stations();
  inline void set_has_tags();
  inline void clear_has_tags();

  ::cloudbox::protobuf::ProgramListInfo* hotprograms_;
  ::cloudbox::protobuf::StationListInfo* stations_;
  ::cloudbox::protobuf::TagListInfo* tags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_liveinfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_liveinfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_liveinfo_2eproto();
  friend void protobuf_ShutdownFile_liveinfo_2eproto();

  void InitAsDefaultInstance();
  static LiveInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// ProgramInfo

// optional string id = 1;
inline bool ProgramInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProgramInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProgramInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProgramInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ProgramInfo::id() const {
  return *id_;
}
inline void ProgramInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ProgramInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ProgramInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgramInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ProgramInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgramInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string station = 2;
inline bool ProgramInfo::has_station() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProgramInfo::set_has_station() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProgramInfo::clear_has_station() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProgramInfo::clear_station() {
  if (station_ != &::google::protobuf::internal::kEmptyString) {
    station_->clear();
  }
  clear_has_station();
}
inline const ::std::string& ProgramInfo::station() const {
  return *station_;
}
inline void ProgramInfo::set_station(const ::std::string& value) {
  set_has_station();
  if (station_ == &::google::protobuf::internal::kEmptyString) {
    station_ = new ::std::string;
  }
  station_->assign(value);
}
inline void ProgramInfo::set_station(const char* value) {
  set_has_station();
  if (station_ == &::google::protobuf::internal::kEmptyString) {
    station_ = new ::std::string;
  }
  station_->assign(value);
}
inline void ProgramInfo::set_station(const char* value, size_t size) {
  set_has_station();
  if (station_ == &::google::protobuf::internal::kEmptyString) {
    station_ = new ::std::string;
  }
  station_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgramInfo::mutable_station() {
  set_has_station();
  if (station_ == &::google::protobuf::internal::kEmptyString) {
    station_ = new ::std::string;
  }
  return station_;
}
inline ::std::string* ProgramInfo::release_station() {
  clear_has_station();
  if (station_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = station_;
    station_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgramInfo::set_allocated_station(::std::string* station) {
  if (station_ != &::google::protobuf::internal::kEmptyString) {
    delete station_;
  }
  if (station) {
    set_has_station();
    station_ = station;
  } else {
    clear_has_station();
    station_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool ProgramInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProgramInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProgramInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProgramInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProgramInfo::name() const {
  return *name_;
}
inline void ProgramInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProgramInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProgramInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgramInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProgramInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgramInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string start = 4;
inline bool ProgramInfo::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProgramInfo::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProgramInfo::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProgramInfo::clear_start() {
  if (start_ != &::google::protobuf::internal::kEmptyString) {
    start_->clear();
  }
  clear_has_start();
}
inline const ::std::string& ProgramInfo::start() const {
  return *start_;
}
inline void ProgramInfo::set_start(const ::std::string& value) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::kEmptyString) {
    start_ = new ::std::string;
  }
  start_->assign(value);
}
inline void ProgramInfo::set_start(const char* value) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::kEmptyString) {
    start_ = new ::std::string;
  }
  start_->assign(value);
}
inline void ProgramInfo::set_start(const char* value, size_t size) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::kEmptyString) {
    start_ = new ::std::string;
  }
  start_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgramInfo::mutable_start() {
  set_has_start();
  if (start_ == &::google::protobuf::internal::kEmptyString) {
    start_ = new ::std::string;
  }
  return start_;
}
inline ::std::string* ProgramInfo::release_start() {
  clear_has_start();
  if (start_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_;
    start_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgramInfo::set_allocated_start(::std::string* start) {
  if (start_ != &::google::protobuf::internal::kEmptyString) {
    delete start_;
  }
  if (start) {
    set_has_start();
    start_ = start;
  } else {
    clear_has_start();
    start_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string end = 5;
inline bool ProgramInfo::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProgramInfo::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProgramInfo::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProgramInfo::clear_end() {
  if (end_ != &::google::protobuf::internal::kEmptyString) {
    end_->clear();
  }
  clear_has_end();
}
inline const ::std::string& ProgramInfo::end() const {
  return *end_;
}
inline void ProgramInfo::set_end(const ::std::string& value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::kEmptyString) {
    end_ = new ::std::string;
  }
  end_->assign(value);
}
inline void ProgramInfo::set_end(const char* value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::kEmptyString) {
    end_ = new ::std::string;
  }
  end_->assign(value);
}
inline void ProgramInfo::set_end(const char* value, size_t size) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::kEmptyString) {
    end_ = new ::std::string;
  }
  end_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgramInfo::mutable_end() {
  set_has_end();
  if (end_ == &::google::protobuf::internal::kEmptyString) {
    end_ = new ::std::string;
  }
  return end_;
}
inline ::std::string* ProgramInfo::release_end() {
  clear_has_end();
  if (end_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = end_;
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgramInfo::set_allocated_end(::std::string* end) {
  if (end_ != &::google::protobuf::internal::kEmptyString) {
    delete end_;
  }
  if (end) {
    set_has_end();
    end_ = end;
  } else {
    clear_has_end();
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 startTimestamp = 6;
inline bool ProgramInfo::has_starttimestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProgramInfo::set_has_starttimestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProgramInfo::clear_has_starttimestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProgramInfo::clear_starttimestamp() {
  starttimestamp_ = 0;
  clear_has_starttimestamp();
}
inline ::google::protobuf::int32 ProgramInfo::starttimestamp() const {
  return starttimestamp_;
}
inline void ProgramInfo::set_starttimestamp(::google::protobuf::int32 value) {
  set_has_starttimestamp();
  starttimestamp_ = value;
}

// optional int32 endTimestamp = 7;
inline bool ProgramInfo::has_endtimestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProgramInfo::set_has_endtimestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProgramInfo::clear_has_endtimestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProgramInfo::clear_endtimestamp() {
  endtimestamp_ = 0;
  clear_has_endtimestamp();
}
inline ::google::protobuf::int32 ProgramInfo::endtimestamp() const {
  return endtimestamp_;
}
inline void ProgramInfo::set_endtimestamp(::google::protobuf::int32 value) {
  set_has_endtimestamp();
  endtimestamp_ = value;
}

// optional int32 isHot = 8;
inline bool ProgramInfo::has_ishot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProgramInfo::set_has_ishot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProgramInfo::clear_has_ishot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProgramInfo::clear_ishot() {
  ishot_ = 0;
  clear_has_ishot();
}
inline ::google::protobuf::int32 ProgramInfo::ishot() const {
  return ishot_;
}
inline void ProgramInfo::set_ishot(::google::protobuf::int32 value) {
  set_has_ishot();
  ishot_ = value;
}

// optional .cloudbox.protobuf.ImageInfo img = 9;
inline bool ProgramInfo::has_img() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProgramInfo::set_has_img() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProgramInfo::clear_has_img() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProgramInfo::clear_img() {
  if (img_ != NULL) img_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_img();
}
inline const ::cloudbox::protobuf::ImageInfo& ProgramInfo::img() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return img_ != NULL ? *img_ : *default_instance().img_;
#else
  return img_ != NULL ? *img_ : *default_instance_->img_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* ProgramInfo::mutable_img() {
  set_has_img();
  if (img_ == NULL) img_ = new ::cloudbox::protobuf::ImageInfo;
  return img_;
}
inline ::cloudbox::protobuf::ImageInfo* ProgramInfo::release_img() {
  clear_has_img();
  ::cloudbox::protobuf::ImageInfo* temp = img_;
  img_ = NULL;
  return temp;
}
inline void ProgramInfo::set_allocated_img(::cloudbox::protobuf::ImageInfo* img) {
  delete img_;
  img_ = img;
  if (img) {
    set_has_img();
  } else {
    clear_has_img();
  }
}

// optional int32 code = 10;
inline bool ProgramInfo::has_code() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProgramInfo::set_has_code() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProgramInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProgramInfo::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ProgramInfo::code() const {
  return code_;
}
inline void ProgramInfo::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string stationName = 11;
inline bool ProgramInfo::has_stationname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProgramInfo::set_has_stationname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProgramInfo::clear_has_stationname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProgramInfo::clear_stationname() {
  if (stationname_ != &::google::protobuf::internal::kEmptyString) {
    stationname_->clear();
  }
  clear_has_stationname();
}
inline const ::std::string& ProgramInfo::stationname() const {
  return *stationname_;
}
inline void ProgramInfo::set_stationname(const ::std::string& value) {
  set_has_stationname();
  if (stationname_ == &::google::protobuf::internal::kEmptyString) {
    stationname_ = new ::std::string;
  }
  stationname_->assign(value);
}
inline void ProgramInfo::set_stationname(const char* value) {
  set_has_stationname();
  if (stationname_ == &::google::protobuf::internal::kEmptyString) {
    stationname_ = new ::std::string;
  }
  stationname_->assign(value);
}
inline void ProgramInfo::set_stationname(const char* value, size_t size) {
  set_has_stationname();
  if (stationname_ == &::google::protobuf::internal::kEmptyString) {
    stationname_ = new ::std::string;
  }
  stationname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgramInfo::mutable_stationname() {
  set_has_stationname();
  if (stationname_ == &::google::protobuf::internal::kEmptyString) {
    stationname_ = new ::std::string;
  }
  return stationname_;
}
inline ::std::string* ProgramInfo::release_stationname() {
  clear_has_stationname();
  if (stationname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stationname_;
    stationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgramInfo::set_allocated_stationname(::std::string* stationname) {
  if (stationname_ != &::google::protobuf::internal::kEmptyString) {
    delete stationname_;
  }
  if (stationname) {
    set_has_stationname();
    stationname_ = stationname;
  } else {
    clear_has_stationname();
    stationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cloudbox.protobuf.ImageInfo icon = 12;
inline bool ProgramInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProgramInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProgramInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProgramInfo::clear_icon() {
  if (icon_ != NULL) icon_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_icon();
}
inline const ::cloudbox::protobuf::ImageInfo& ProgramInfo::icon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return icon_ != NULL ? *icon_ : *default_instance().icon_;
#else
  return icon_ != NULL ? *icon_ : *default_instance_->icon_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* ProgramInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == NULL) icon_ = new ::cloudbox::protobuf::ImageInfo;
  return icon_;
}
inline ::cloudbox::protobuf::ImageInfo* ProgramInfo::release_icon() {
  clear_has_icon();
  ::cloudbox::protobuf::ImageInfo* temp = icon_;
  icon_ = NULL;
  return temp;
}
inline void ProgramInfo::set_allocated_icon(::cloudbox::protobuf::ImageInfo* icon) {
  delete icon_;
  icon_ = icon;
  if (icon) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
}

// -------------------------------------------------------------------

// StationInfo

// optional string id = 1;
inline bool StationInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StationInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StationInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StationInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& StationInfo::id() const {
  return *id_;
}
inline void StationInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StationInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StationInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* StationInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 code = 2;
inline bool StationInfo::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StationInfo::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StationInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StationInfo::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StationInfo::code() const {
  return code_;
}
inline void StationInfo::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string name = 3;
inline bool StationInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StationInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StationInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StationInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StationInfo::name() const {
  return *name_;
}
inline void StationInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StationInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StationInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StationInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .cloudbox.protobuf.PlaySiteInfo sites = 4;
inline int StationInfo::sites_size() const {
  return sites_.size();
}
inline void StationInfo::clear_sites() {
  sites_.Clear();
}
inline const ::cloudbox::protobuf::PlaySiteInfo& StationInfo::sites(int index) const {
  return sites_.Get(index);
}
inline ::cloudbox::protobuf::PlaySiteInfo* StationInfo::mutable_sites(int index) {
  return sites_.Mutable(index);
}
inline ::cloudbox::protobuf::PlaySiteInfo* StationInfo::add_sites() {
  return sites_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlaySiteInfo >&
StationInfo::sites() const {
  return sites_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::PlaySiteInfo >*
StationInfo::mutable_sites() {
  return &sites_;
}

// optional .cloudbox.protobuf.ImageInfo icon = 5;
inline bool StationInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StationInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StationInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StationInfo::clear_icon() {
  if (icon_ != NULL) icon_->::cloudbox::protobuf::ImageInfo::Clear();
  clear_has_icon();
}
inline const ::cloudbox::protobuf::ImageInfo& StationInfo::icon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return icon_ != NULL ? *icon_ : *default_instance().icon_;
#else
  return icon_ != NULL ? *icon_ : *default_instance_->icon_;
#endif
}
inline ::cloudbox::protobuf::ImageInfo* StationInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == NULL) icon_ = new ::cloudbox::protobuf::ImageInfo;
  return icon_;
}
inline ::cloudbox::protobuf::ImageInfo* StationInfo::release_icon() {
  clear_has_icon();
  ::cloudbox::protobuf::ImageInfo* temp = icon_;
  icon_ = NULL;
  return temp;
}
inline void StationInfo::set_allocated_icon(::cloudbox::protobuf::ImageInfo* icon) {
  delete icon_;
  icon_ = icon;
  if (icon) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
}

// repeated int32 tags = 6;
inline int StationInfo::tags_size() const {
  return tags_.size();
}
inline void StationInfo::clear_tags() {
  tags_.Clear();
}
inline ::google::protobuf::int32 StationInfo::tags(int index) const {
  return tags_.Get(index);
}
inline void StationInfo::set_tags(int index, ::google::protobuf::int32 value) {
  tags_.Set(index, value);
}
inline void StationInfo::add_tags(::google::protobuf::int32 value) {
  tags_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
StationInfo::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
StationInfo::mutable_tags() {
  return &tags_;
}

// repeated .cloudbox.protobuf.ProgramInfo programs = 7;
inline int StationInfo::programs_size() const {
  return programs_.size();
}
inline void StationInfo::clear_programs() {
  programs_.Clear();
}
inline const ::cloudbox::protobuf::ProgramInfo& StationInfo::programs(int index) const {
  return programs_.Get(index);
}
inline ::cloudbox::protobuf::ProgramInfo* StationInfo::mutable_programs(int index) {
  return programs_.Mutable(index);
}
inline ::cloudbox::protobuf::ProgramInfo* StationInfo::add_programs() {
  return programs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >&
StationInfo::programs() const {
  return programs_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >*
StationInfo::mutable_programs() {
  return &programs_;
}

// -------------------------------------------------------------------

// TagInfo

// optional int32 code = 1;
inline bool TagInfo::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TagInfo::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TagInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TagInfo::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 TagInfo::code() const {
  return code_;
}
inline void TagInfo::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string name = 2;
inline bool TagInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TagInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TagInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TagInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TagInfo::name() const {
  return *name_;
}
inline void TagInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TagInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TagInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TagInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TagInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TagInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProgramListInfo

// optional int32 total = 1;
inline bool ProgramListInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProgramListInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProgramListInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProgramListInfo::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 ProgramListInfo::total() const {
  return total_;
}
inline void ProgramListInfo::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated .cloudbox.protobuf.ProgramInfo result = 2;
inline int ProgramListInfo::result_size() const {
  return result_.size();
}
inline void ProgramListInfo::clear_result() {
  result_.Clear();
}
inline const ::cloudbox::protobuf::ProgramInfo& ProgramListInfo::result(int index) const {
  return result_.Get(index);
}
inline ::cloudbox::protobuf::ProgramInfo* ProgramListInfo::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::cloudbox::protobuf::ProgramInfo* ProgramListInfo::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >&
ProgramListInfo::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::ProgramInfo >*
ProgramListInfo::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// StationListInfo

// optional int32 total = 1;
inline bool StationListInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StationListInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StationListInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StationListInfo::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 StationListInfo::total() const {
  return total_;
}
inline void StationListInfo::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated .cloudbox.protobuf.StationInfo result = 2;
inline int StationListInfo::result_size() const {
  return result_.size();
}
inline void StationListInfo::clear_result() {
  result_.Clear();
}
inline const ::cloudbox::protobuf::StationInfo& StationListInfo::result(int index) const {
  return result_.Get(index);
}
inline ::cloudbox::protobuf::StationInfo* StationListInfo::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::cloudbox::protobuf::StationInfo* StationListInfo::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >&
StationListInfo::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >*
StationListInfo::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// TagListInfo

// optional int32 total = 1;
inline bool TagListInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TagListInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TagListInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TagListInfo::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 TagListInfo::total() const {
  return total_;
}
inline void TagListInfo::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated .cloudbox.protobuf.TagInfo result = 2;
inline int TagListInfo::result_size() const {
  return result_.size();
}
inline void TagListInfo::clear_result() {
  result_.Clear();
}
inline const ::cloudbox::protobuf::TagInfo& TagListInfo::result(int index) const {
  return result_.Get(index);
}
inline ::cloudbox::protobuf::TagInfo* TagListInfo::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::cloudbox::protobuf::TagInfo* TagListInfo::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::TagInfo >&
TagListInfo::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::TagInfo >*
TagListInfo::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// StationTagInfo

// optional .cloudbox.protobuf.TagInfo tag = 1;
inline bool StationTagInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StationTagInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StationTagInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StationTagInfo::clear_tag() {
  if (tag_ != NULL) tag_->::cloudbox::protobuf::TagInfo::Clear();
  clear_has_tag();
}
inline const ::cloudbox::protobuf::TagInfo& StationTagInfo::tag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tag_ != NULL ? *tag_ : *default_instance().tag_;
#else
  return tag_ != NULL ? *tag_ : *default_instance_->tag_;
#endif
}
inline ::cloudbox::protobuf::TagInfo* StationTagInfo::mutable_tag() {
  set_has_tag();
  if (tag_ == NULL) tag_ = new ::cloudbox::protobuf::TagInfo;
  return tag_;
}
inline ::cloudbox::protobuf::TagInfo* StationTagInfo::release_tag() {
  clear_has_tag();
  ::cloudbox::protobuf::TagInfo* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline void StationTagInfo::set_allocated_tag(::cloudbox::protobuf::TagInfo* tag) {
  delete tag_;
  tag_ = tag;
  if (tag) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
}

// repeated .cloudbox.protobuf.StationInfo stations = 2;
inline int StationTagInfo::stations_size() const {
  return stations_.size();
}
inline void StationTagInfo::clear_stations() {
  stations_.Clear();
}
inline const ::cloudbox::protobuf::StationInfo& StationTagInfo::stations(int index) const {
  return stations_.Get(index);
}
inline ::cloudbox::protobuf::StationInfo* StationTagInfo::mutable_stations(int index) {
  return stations_.Mutable(index);
}
inline ::cloudbox::protobuf::StationInfo* StationTagInfo::add_stations() {
  return stations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >&
StationTagInfo::stations() const {
  return stations_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationInfo >*
StationTagInfo::mutable_stations() {
  return &stations_;
}

// -------------------------------------------------------------------

// StationTagList

// optional int32 total = 1;
inline bool StationTagList::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StationTagList::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StationTagList::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StationTagList::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 StationTagList::total() const {
  return total_;
}
inline void StationTagList::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated .cloudbox.protobuf.StationTagInfo result = 2;
inline int StationTagList::result_size() const {
  return result_.size();
}
inline void StationTagList::clear_result() {
  result_.Clear();
}
inline const ::cloudbox::protobuf::StationTagInfo& StationTagList::result(int index) const {
  return result_.Get(index);
}
inline ::cloudbox::protobuf::StationTagInfo* StationTagList::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::cloudbox::protobuf::StationTagInfo* StationTagList::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationTagInfo >&
StationTagList::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudbox::protobuf::StationTagInfo >*
StationTagList::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// LiveInfo

// optional .cloudbox.protobuf.ProgramListInfo hotPrograms = 1;
inline bool LiveInfo::has_hotprograms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LiveInfo::set_has_hotprograms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LiveInfo::clear_has_hotprograms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LiveInfo::clear_hotprograms() {
  if (hotprograms_ != NULL) hotprograms_->::cloudbox::protobuf::ProgramListInfo::Clear();
  clear_has_hotprograms();
}
inline const ::cloudbox::protobuf::ProgramListInfo& LiveInfo::hotprograms() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hotprograms_ != NULL ? *hotprograms_ : *default_instance().hotprograms_;
#else
  return hotprograms_ != NULL ? *hotprograms_ : *default_instance_->hotprograms_;
#endif
}
inline ::cloudbox::protobuf::ProgramListInfo* LiveInfo::mutable_hotprograms() {
  set_has_hotprograms();
  if (hotprograms_ == NULL) hotprograms_ = new ::cloudbox::protobuf::ProgramListInfo;
  return hotprograms_;
}
inline ::cloudbox::protobuf::ProgramListInfo* LiveInfo::release_hotprograms() {
  clear_has_hotprograms();
  ::cloudbox::protobuf::ProgramListInfo* temp = hotprograms_;
  hotprograms_ = NULL;
  return temp;
}
inline void LiveInfo::set_allocated_hotprograms(::cloudbox::protobuf::ProgramListInfo* hotprograms) {
  delete hotprograms_;
  hotprograms_ = hotprograms;
  if (hotprograms) {
    set_has_hotprograms();
  } else {
    clear_has_hotprograms();
  }
}

// optional .cloudbox.protobuf.StationListInfo stations = 2;
inline bool LiveInfo::has_stations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LiveInfo::set_has_stations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LiveInfo::clear_has_stations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LiveInfo::clear_stations() {
  if (stations_ != NULL) stations_->::cloudbox::protobuf::StationListInfo::Clear();
  clear_has_stations();
}
inline const ::cloudbox::protobuf::StationListInfo& LiveInfo::stations() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stations_ != NULL ? *stations_ : *default_instance().stations_;
#else
  return stations_ != NULL ? *stations_ : *default_instance_->stations_;
#endif
}
inline ::cloudbox::protobuf::StationListInfo* LiveInfo::mutable_stations() {
  set_has_stations();
  if (stations_ == NULL) stations_ = new ::cloudbox::protobuf::StationListInfo;
  return stations_;
}
inline ::cloudbox::protobuf::StationListInfo* LiveInfo::release_stations() {
  clear_has_stations();
  ::cloudbox::protobuf::StationListInfo* temp = stations_;
  stations_ = NULL;
  return temp;
}
inline void LiveInfo::set_allocated_stations(::cloudbox::protobuf::StationListInfo* stations) {
  delete stations_;
  stations_ = stations;
  if (stations) {
    set_has_stations();
  } else {
    clear_has_stations();
  }
}

// optional .cloudbox.protobuf.TagListInfo tags = 3;
inline bool LiveInfo::has_tags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LiveInfo::set_has_tags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LiveInfo::clear_has_tags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LiveInfo::clear_tags() {
  if (tags_ != NULL) tags_->::cloudbox::protobuf::TagListInfo::Clear();
  clear_has_tags();
}
inline const ::cloudbox::protobuf::TagListInfo& LiveInfo::tags() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tags_ != NULL ? *tags_ : *default_instance().tags_;
#else
  return tags_ != NULL ? *tags_ : *default_instance_->tags_;
#endif
}
inline ::cloudbox::protobuf::TagListInfo* LiveInfo::mutable_tags() {
  set_has_tags();
  if (tags_ == NULL) tags_ = new ::cloudbox::protobuf::TagListInfo;
  return tags_;
}
inline ::cloudbox::protobuf::TagListInfo* LiveInfo::release_tags() {
  clear_has_tags();
  ::cloudbox::protobuf::TagListInfo* temp = tags_;
  tags_ = NULL;
  return temp;
}
inline void LiveInfo::set_allocated_tags(::cloudbox::protobuf::TagListInfo* tags) {
  delete tags_;
  tags_ = tags;
  if (tags) {
    set_has_tags();
  } else {
    clear_has_tags();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace cloudbox

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_liveinfo_2eproto__INCLUDED
